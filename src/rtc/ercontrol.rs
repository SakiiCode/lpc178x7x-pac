# [doc = "Register `ERCONTROL` reader"] pub type R = crate :: R < ErcontrolSpec > ; # [doc = "Register `ERCONTROL` writer"] pub type W = crate :: W < ErcontrolSpec > ; # [doc = "Interrupt and wakeup enable for channel 0.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Enum { # [doc = "0: No interrupt or wakeup will be generated by event channel 0."] NoInterruptOrWake = 0 , # [doc = "1: An event in channel 0 will trigger an (RTC) interrupt and a wake-up request."] AnEventInChannel_ = 1 , } impl From < Enum > for bool { # [inline (always)] fn from (variant : Enum) -> Self { variant as u8 != 0 } } # [doc = "Field `INTWAKE_EN0` reader - Interrupt and wakeup enable for channel 0."] pub type IntwakeEn0R = crate :: BitReader < Enum > ; impl IntwakeEn0R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Enum { match self . bits { false => Enum :: NoInterruptOrWake , true => Enum :: AnEventInChannel_ , } } # [doc = "No interrupt or wakeup will be generated by event channel 0."] # [inline (always)] pub fn is_no_interrupt_or_wake (& self) -> bool { * self == Enum :: NoInterruptOrWake } # [doc = "An event in channel 0 will trigger an (RTC) interrupt and a wake-up request."] # [inline (always)] pub fn is_an_event_in_channel_ (& self) -> bool { * self == Enum :: AnEventInChannel_ } } # [doc = "Field `INTWAKE_EN0` writer - Interrupt and wakeup enable for channel 0."] pub type IntwakeEn0W < 'a , REG > = crate :: BitWriter < 'a , REG , Enum > ; impl < 'a , REG > IntwakeEn0W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "No interrupt or wakeup will be generated by event channel 0."] # [inline (always)] pub fn no_interrupt_or_wake (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: NoInterruptOrWake) } # [doc = "An event in channel 0 will trigger an (RTC) interrupt and a wake-up request."] # [inline (always)] pub fn an_event_in_channel_ (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: AnEventInChannel_) } } # [doc = "Enables automatically clearing the RTC general purpose registers when an event occurs on channel 0.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Enum { # [doc = "0: Channel 0 has no influence on the general purpose registers."] Nogpreg = 0 , # [doc = "1: An event in channel 0 will clear the general purpose registers asynchronously."] Clrgpreg = 1 , } impl From < Enum > for bool { # [inline (always)] fn from (variant : Enum) -> Self { variant as u8 != 0 } } # [doc = "Field `GPCLEAR_EN0` reader - Enables automatically clearing the RTC general purpose registers when an event occurs on channel 0."] pub type GpclearEn0R = crate :: BitReader < Enum > ; impl GpclearEn0R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Enum { match self . bits { false => Enum :: Nogpreg , true => Enum :: Clrgpreg , } } # [doc = "Channel 0 has no influence on the general purpose registers."] # [inline (always)] pub fn is_nogpreg (& self) -> bool { * self == Enum :: Nogpreg } # [doc = "An event in channel 0 will clear the general purpose registers asynchronously."] # [inline (always)] pub fn is_clrgpreg (& self) -> bool { * self == Enum :: Clrgpreg } } # [doc = "Field `GPCLEAR_EN0` writer - Enables automatically clearing the RTC general purpose registers when an event occurs on channel 0."] pub type GpclearEn0W < 'a , REG > = crate :: BitWriter < 'a , REG , Enum > ; impl < 'a , REG > GpclearEn0W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Channel 0 has no influence on the general purpose registers."] # [inline (always)] pub fn nogpreg (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: Nogpreg) } # [doc = "An event in channel 0 will clear the general purpose registers asynchronously."] # [inline (always)] pub fn clrgpreg (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: Clrgpreg) } } # [doc = "Selects the polarity of an event on input pin RTC_EV0.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Enum { # [doc = "0: A channel 0 event is defined as a negative edge on RTC_EV0."] Neg = 0 , # [doc = "1: A channel 0 event is defined as a positive edge on RTC_EV0."] Pos = 1 , } impl From < Enum > for bool { # [inline (always)] fn from (variant : Enum) -> Self { variant as u8 != 0 } } # [doc = "Field `POL0` reader - Selects the polarity of an event on input pin RTC_EV0."] pub type Pol0R = crate :: BitReader < Enum > ; impl Pol0R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Enum { match self . bits { false => Enum :: Neg , true => Enum :: Pos , } } # [doc = "A channel 0 event is defined as a negative edge on RTC_EV0."] # [inline (always)] pub fn is_neg (& self) -> bool { * self == Enum :: Neg } # [doc = "A channel 0 event is defined as a positive edge on RTC_EV0."] # [inline (always)] pub fn is_pos (& self) -> bool { * self == Enum :: Pos } } # [doc = "Field `POL0` writer - Selects the polarity of an event on input pin RTC_EV0."] pub type Pol0W < 'a , REG > = crate :: BitWriter < 'a , REG , Enum > ; impl < 'a , REG > Pol0W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "A channel 0 event is defined as a negative edge on RTC_EV0."] # [inline (always)] pub fn neg (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: Neg) } # [doc = "A channel 0 event is defined as a positive edge on RTC_EV0."] # [inline (always)] pub fn pos (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: Pos) } } # [doc = "Event enable control for channel 0.\\[1\\]\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Enum { # [doc = "0: Event 0 input is disabled and forced high internally."] Disabled = 0 , # [doc = "1: Event 0 input is enabled."] Enabled = 1 , } impl From < Enum > for bool { # [inline (always)] fn from (variant : Enum) -> Self { variant as u8 != 0 } } # [doc = "Field `EV0_INPUT_EN` reader - Event enable control for channel 0.\\[1\\]"] pub type Ev0InputEnR = crate :: BitReader < Enum > ; impl Ev0InputEnR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Enum { match self . bits { false => Enum :: Disabled , true => Enum :: Enabled , } } # [doc = "Event 0 input is disabled and forced high internally."] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Enum :: Disabled } # [doc = "Event 0 input is enabled."] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Enum :: Enabled } } # [doc = "Field `EV0_INPUT_EN` writer - Event enable control for channel 0.\\[1\\]"] pub type Ev0InputEnW < 'a , REG > = crate :: BitWriter < 'a , REG , Enum > ; impl < 'a , REG > Ev0InputEnW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Event 0 input is disabled and forced high internally."] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: Disabled) } # [doc = "Event 0 input is enabled."] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: Enabled) } } # [doc = "Interrupt and wakeup enable for channel 1.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Enum { # [doc = "0: No interrupt or wakeup will be generated by event channel 1."] NoInterruptOrWake = 0 , # [doc = "1: An event in channel 1 will trigger an (RTC) interrupt and a wake-up request."] Wakeup = 1 , } impl From < Enum > for bool { # [inline (always)] fn from (variant : Enum) -> Self { variant as u8 != 0 } } # [doc = "Field `INTWAKE_EN1` reader - Interrupt and wakeup enable for channel 1."] pub type IntwakeEn1R = crate :: BitReader < Enum > ; impl IntwakeEn1R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Enum { match self . bits { false => Enum :: NoInterruptOrWake , true => Enum :: Wakeup , } } # [doc = "No interrupt or wakeup will be generated by event channel 1."] # [inline (always)] pub fn is_no_interrupt_or_wake (& self) -> bool { * self == Enum :: NoInterruptOrWake } # [doc = "An event in channel 1 will trigger an (RTC) interrupt and a wake-up request."] # [inline (always)] pub fn is_wakeup (& self) -> bool { * self == Enum :: Wakeup } } # [doc = "Field `INTWAKE_EN1` writer - Interrupt and wakeup enable for channel 1."] pub type IntwakeEn1W < 'a , REG > = crate :: BitWriter < 'a , REG , Enum > ; impl < 'a , REG > IntwakeEn1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "No interrupt or wakeup will be generated by event channel 1."] # [inline (always)] pub fn no_interrupt_or_wake (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: NoInterruptOrWake) } # [doc = "An event in channel 1 will trigger an (RTC) interrupt and a wake-up request."] # [inline (always)] pub fn wakeup (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: Wakeup) } } # [doc = "Enables automatically clearing the RTC general purpose registers when an event occurs on channel 1.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Enum { # [doc = "0: Channel 1 has no influence on the general purpose registers."] Nogpreg = 0 , # [doc = "1: A n event in channel 1 will clear the general purpose registers asynchronously."] Clrgpreg = 1 , } impl From < Enum > for bool { # [inline (always)] fn from (variant : Enum) -> Self { variant as u8 != 0 } } # [doc = "Field `GPCLEAR_EN1` reader - Enables automatically clearing the RTC general purpose registers when an event occurs on channel 1."] pub type GpclearEn1R = crate :: BitReader < Enum > ; impl GpclearEn1R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Enum { match self . bits { false => Enum :: Nogpreg , true => Enum :: Clrgpreg , } } # [doc = "Channel 1 has no influence on the general purpose registers."] # [inline (always)] pub fn is_nogpreg (& self) -> bool { * self == Enum :: Nogpreg } # [doc = "A n event in channel 1 will clear the general purpose registers asynchronously."] # [inline (always)] pub fn is_clrgpreg (& self) -> bool { * self == Enum :: Clrgpreg } } # [doc = "Field `GPCLEAR_EN1` writer - Enables automatically clearing the RTC general purpose registers when an event occurs on channel 1."] pub type GpclearEn1W < 'a , REG > = crate :: BitWriter < 'a , REG , Enum > ; impl < 'a , REG > GpclearEn1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Channel 1 has no influence on the general purpose registers."] # [inline (always)] pub fn nogpreg (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: Nogpreg) } # [doc = "A n event in channel 1 will clear the general purpose registers asynchronously."] # [inline (always)] pub fn clrgpreg (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: Clrgpreg) } } # [doc = "Selects the polarity of an event on input pin RTC_EV1.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Enum { # [doc = "0: A channel 1 event is defined as a negative edge on RTC_EV1."] Neg = 0 , # [doc = "1: A channel 1 event is defined as a positive edge on RTC_EV1."] Pos = 1 , } impl From < Enum > for bool { # [inline (always)] fn from (variant : Enum) -> Self { variant as u8 != 0 } } # [doc = "Field `POL1` reader - Selects the polarity of an event on input pin RTC_EV1."] pub type Pol1R = crate :: BitReader < Enum > ; impl Pol1R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Enum { match self . bits { false => Enum :: Neg , true => Enum :: Pos , } } # [doc = "A channel 1 event is defined as a negative edge on RTC_EV1."] # [inline (always)] pub fn is_neg (& self) -> bool { * self == Enum :: Neg } # [doc = "A channel 1 event is defined as a positive edge on RTC_EV1."] # [inline (always)] pub fn is_pos (& self) -> bool { * self == Enum :: Pos } } # [doc = "Field `POL1` writer - Selects the polarity of an event on input pin RTC_EV1."] pub type Pol1W < 'a , REG > = crate :: BitWriter < 'a , REG , Enum > ; impl < 'a , REG > Pol1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "A channel 1 event is defined as a negative edge on RTC_EV1."] # [inline (always)] pub fn neg (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: Neg) } # [doc = "A channel 1 event is defined as a positive edge on RTC_EV1."] # [inline (always)] pub fn pos (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: Pos) } } # [doc = "Event enable control for channel 1.\\[1\\]\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Enum { # [doc = "0: Event 1 input is disabled and forced high internally."] Disabled = 0 , # [doc = "1: Event 1 input is enabled."] Enabled = 1 , } impl From < Enum > for bool { # [inline (always)] fn from (variant : Enum) -> Self { variant as u8 != 0 } } # [doc = "Field `EV1_INPUT_EN` reader - Event enable control for channel 1.\\[1\\]"] pub type Ev1InputEnR = crate :: BitReader < Enum > ; impl Ev1InputEnR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Enum { match self . bits { false => Enum :: Disabled , true => Enum :: Enabled , } } # [doc = "Event 1 input is disabled and forced high internally."] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Enum :: Disabled } # [doc = "Event 1 input is enabled."] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Enum :: Enabled } } # [doc = "Field `EV1_INPUT_EN` writer - Event enable control for channel 1.\\[1\\]"] pub type Ev1InputEnW < 'a , REG > = crate :: BitWriter < 'a , REG , Enum > ; impl < 'a , REG > Ev1InputEnW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Event 1 input is disabled and forced high internally."] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: Disabled) } # [doc = "Event 1 input is enabled."] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: Enabled) } } # [doc = "Interrupt and wakeup enable for channel 2.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Enum { # [doc = "0: No interrupt or wakeup will be generated by event channel 2."] NoInterruptOrWake = 0 , # [doc = "1: An event in channel 2 will trigger an (RTC) interrupt and a wake-up request."] Wakeup = 1 , } impl From < Enum > for bool { # [inline (always)] fn from (variant : Enum) -> Self { variant as u8 != 0 } } # [doc = "Field `INTWAKE_EN2` reader - Interrupt and wakeup enable for channel 2."] pub type IntwakeEn2R = crate :: BitReader < Enum > ; impl IntwakeEn2R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Enum { match self . bits { false => Enum :: NoInterruptOrWake , true => Enum :: Wakeup , } } # [doc = "No interrupt or wakeup will be generated by event channel 2."] # [inline (always)] pub fn is_no_interrupt_or_wake (& self) -> bool { * self == Enum :: NoInterruptOrWake } # [doc = "An event in channel 2 will trigger an (RTC) interrupt and a wake-up request."] # [inline (always)] pub fn is_wakeup (& self) -> bool { * self == Enum :: Wakeup } } # [doc = "Field `INTWAKE_EN2` writer - Interrupt and wakeup enable for channel 2."] pub type IntwakeEn2W < 'a , REG > = crate :: BitWriter < 'a , REG , Enum > ; impl < 'a , REG > IntwakeEn2W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "No interrupt or wakeup will be generated by event channel 2."] # [inline (always)] pub fn no_interrupt_or_wake (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: NoInterruptOrWake) } # [doc = "An event in channel 2 will trigger an (RTC) interrupt and a wake-up request."] # [inline (always)] pub fn wakeup (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: Wakeup) } } # [doc = "Enables automatically clearing the RTC general purpose registers when an event occurs on channel 2.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Enum { # [doc = "0: Channel 2 has no influence on the general purpose registers."] Nogpreg = 0 , # [doc = "1: An event in channel 2 will clear the general purpose registers asynchronously."] Clrgpreg = 1 , } impl From < Enum > for bool { # [inline (always)] fn from (variant : Enum) -> Self { variant as u8 != 0 } } # [doc = "Field `GPCLEAR_EN2` reader - Enables automatically clearing the RTC general purpose registers when an event occurs on channel 2."] pub type GpclearEn2R = crate :: BitReader < Enum > ; impl GpclearEn2R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Enum { match self . bits { false => Enum :: Nogpreg , true => Enum :: Clrgpreg , } } # [doc = "Channel 2 has no influence on the general purpose registers."] # [inline (always)] pub fn is_nogpreg (& self) -> bool { * self == Enum :: Nogpreg } # [doc = "An event in channel 2 will clear the general purpose registers asynchronously."] # [inline (always)] pub fn is_clrgpreg (& self) -> bool { * self == Enum :: Clrgpreg } } # [doc = "Field `GPCLEAR_EN2` writer - Enables automatically clearing the RTC general purpose registers when an event occurs on channel 2."] pub type GpclearEn2W < 'a , REG > = crate :: BitWriter < 'a , REG , Enum > ; impl < 'a , REG > GpclearEn2W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Channel 2 has no influence on the general purpose registers."] # [inline (always)] pub fn nogpreg (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: Nogpreg) } # [doc = "An event in channel 2 will clear the general purpose registers asynchronously."] # [inline (always)] pub fn clrgpreg (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: Clrgpreg) } } # [doc = "Selects the polarity of an event on input pin RTC_EV2.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Enum { # [doc = "0: A channel 2 event is defined as a negative edge on RTC_EV2."] Neg = 0 , # [doc = "1: A channel 2 event is defined as a positive edge on RTC_EV2."] Pos = 1 , } impl From < Enum > for bool { # [inline (always)] fn from (variant : Enum) -> Self { variant as u8 != 0 } } # [doc = "Field `POL2` reader - Selects the polarity of an event on input pin RTC_EV2."] pub type Pol2R = crate :: BitReader < Enum > ; impl Pol2R { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Enum { match self . bits { false => Enum :: Neg , true => Enum :: Pos , } } # [doc = "A channel 2 event is defined as a negative edge on RTC_EV2."] # [inline (always)] pub fn is_neg (& self) -> bool { * self == Enum :: Neg } # [doc = "A channel 2 event is defined as a positive edge on RTC_EV2."] # [inline (always)] pub fn is_pos (& self) -> bool { * self == Enum :: Pos } } # [doc = "Field `POL2` writer - Selects the polarity of an event on input pin RTC_EV2."] pub type Pol2W < 'a , REG > = crate :: BitWriter < 'a , REG , Enum > ; impl < 'a , REG > Pol2W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "A channel 2 event is defined as a negative edge on RTC_EV2."] # [inline (always)] pub fn neg (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: Neg) } # [doc = "A channel 2 event is defined as a positive edge on RTC_EV2."] # [inline (always)] pub fn pos (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: Pos) } } # [doc = "Event enable control for channel 2.\\[1\\]\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Enum { # [doc = "0: Event 2 input is disabled and forced high internally."] Disabled = 0 , # [doc = "1: Event 2 input is enabled."] Enabled = 1 , } impl From < Enum > for bool { # [inline (always)] fn from (variant : Enum) -> Self { variant as u8 != 0 } } # [doc = "Field `EV2_INPUT_EN` reader - Event enable control for channel 2.\\[1\\]"] pub type Ev2InputEnR = crate :: BitReader < Enum > ; impl Ev2InputEnR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Enum { match self . bits { false => Enum :: Disabled , true => Enum :: Enabled , } } # [doc = "Event 2 input is disabled and forced high internally."] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Enum :: Disabled } # [doc = "Event 2 input is enabled."] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Enum :: Enabled } } # [doc = "Field `EV2_INPUT_EN` writer - Event enable control for channel 2.\\[1\\]"] pub type Ev2InputEnW < 'a , REG > = crate :: BitWriter < 'a , REG , Enum > ; impl < 'a , REG > Ev2InputEnW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Event 2 input is disabled and forced high internally."] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: Disabled) } # [doc = "Event 2 input is enabled."] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: Enabled) } } # [doc = "Controls enabling the Event Monitor/Recorder and selecting its operating frequency.\\[2\\]\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] # [repr (u8)] pub enum Enum { # [doc = "0: Event Monitor/Recorder clocks are disabled. Operation of the Event Monitor/Recorder is disabled except for asynchronous clearing of GP registers if selected."] Disabled = 0 , # [doc = "1: Enable Event Monitor/Recorder and select a 16 Hz sample clock for event input edge detection and glitch suppression. Pulses (in either direction) shorter than 62.5 ms to 125 ms will be filtered out."] EnableEventMonitor16hz = 1 , # [doc = "2: Enable Event Monitor/Recorder and select a 64 Hz sample clock for event input edge detection and glitch suppression. Pulses (in either direction) shorter than 15.6 ms to 31.2 ms will be filtered out."] EnableEventMonitor64hz = 2 , # [doc = "3: Enable Event Monitor/Recorder and select a 1 kHz sample clock for event input edge detection and glitch suppression. Pulses (in either direction) shorter than 1 ms to 2 ms will be filtered out."] EnableEventMonitor1khz = 3 , } impl From < Enum > for u8 { # [inline (always)] fn from (variant : Enum) -> Self { variant as _ } } impl crate :: FieldSpec for Enum { type Ux = u8 ; } impl crate :: IsEnum for Enum { } # [doc = "Field `ERMODE` reader - Controls enabling the Event Monitor/Recorder and selecting its operating frequency.\\[2\\]"] pub type ErmodeR = crate :: FieldReader < Enum > ; impl ErmodeR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Enum { match self . bits { 0 => Enum :: Disabled , 1 => Enum :: EnableEventMonitor16hz , 2 => Enum :: EnableEventMonitor64hz , 3 => Enum :: EnableEventMonitor1khz , _ => unreachable ! () , } } # [doc = "Event Monitor/Recorder clocks are disabled. Operation of the Event Monitor/Recorder is disabled except for asynchronous clearing of GP registers if selected."] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Enum :: Disabled } # [doc = "Enable Event Monitor/Recorder and select a 16 Hz sample clock for event input edge detection and glitch suppression. Pulses (in either direction) shorter than 62.5 ms to 125 ms will be filtered out."] # [inline (always)] pub fn is_enable_event_monitor16hz (& self) -> bool { * self == Enum :: EnableEventMonitor16hz } # [doc = "Enable Event Monitor/Recorder and select a 64 Hz sample clock for event input edge detection and glitch suppression. Pulses (in either direction) shorter than 15.6 ms to 31.2 ms will be filtered out."] # [inline (always)] pub fn is_enable_event_monitor64hz (& self) -> bool { * self == Enum :: EnableEventMonitor64hz } # [doc = "Enable Event Monitor/Recorder and select a 1 kHz sample clock for event input edge detection and glitch suppression. Pulses (in either direction) shorter than 1 ms to 2 ms will be filtered out."] # [inline (always)] pub fn is_enable_event_monitor1khz (& self) -> bool { * self == Enum :: EnableEventMonitor1khz } } # [doc = "Field `ERMODE` writer - Controls enabling the Event Monitor/Recorder and selecting its operating frequency.\\[2\\]"] pub type ErmodeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Enum , crate :: Safe > ; impl < 'a , REG > ErmodeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Event Monitor/Recorder clocks are disabled. Operation of the Event Monitor/Recorder is disabled except for asynchronous clearing of GP registers if selected."] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: Disabled) } # [doc = "Enable Event Monitor/Recorder and select a 16 Hz sample clock for event input edge detection and glitch suppression. Pulses (in either direction) shorter than 62.5 ms to 125 ms will be filtered out."] # [inline (always)] pub fn enable_event_monitor16hz (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: EnableEventMonitor16hz) } # [doc = "Enable Event Monitor/Recorder and select a 64 Hz sample clock for event input edge detection and glitch suppression. Pulses (in either direction) shorter than 15.6 ms to 31.2 ms will be filtered out."] # [inline (always)] pub fn enable_event_monitor64hz (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: EnableEventMonitor64hz) } # [doc = "Enable Event Monitor/Recorder and select a 1 kHz sample clock for event input edge detection and glitch suppression. Pulses (in either direction) shorter than 1 ms to 2 ms will be filtered out."] # [inline (always)] pub fn enable_event_monitor1khz (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: EnableEventMonitor1khz) } } impl R { # [doc = "Bit 0 - Interrupt and wakeup enable for channel 0."] # [inline (always)] pub fn intwake_en0 (& self) -> IntwakeEn0R { IntwakeEn0R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Enables automatically clearing the RTC general purpose registers when an event occurs on channel 0."] # [inline (always)] pub fn gpclear_en0 (& self) -> GpclearEn0R { GpclearEn0R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Selects the polarity of an event on input pin RTC_EV0."] # [inline (always)] pub fn pol0 (& self) -> Pol0R { Pol0R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Event enable control for channel 0.\\[1\\]"] # [inline (always)] pub fn ev0_input_en (& self) -> Ev0InputEnR { Ev0InputEnR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 10 - Interrupt and wakeup enable for channel 1."] # [inline (always)] pub fn intwake_en1 (& self) -> IntwakeEn1R { IntwakeEn1R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Enables automatically clearing the RTC general purpose registers when an event occurs on channel 1."] # [inline (always)] pub fn gpclear_en1 (& self) -> GpclearEn1R { GpclearEn1R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - Selects the polarity of an event on input pin RTC_EV1."] # [inline (always)] pub fn pol1 (& self) -> Pol1R { Pol1R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - Event enable control for channel 1.\\[1\\]"] # [inline (always)] pub fn ev1_input_en (& self) -> Ev1InputEnR { Ev1InputEnR :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 20 - Interrupt and wakeup enable for channel 2."] # [inline (always)] pub fn intwake_en2 (& self) -> IntwakeEn2R { IntwakeEn2R :: new (((self . bits >> 20) & 1) != 0) } # [doc = "Bit 21 - Enables automatically clearing the RTC general purpose registers when an event occurs on channel 2."] # [inline (always)] pub fn gpclear_en2 (& self) -> GpclearEn2R { GpclearEn2R :: new (((self . bits >> 21) & 1) != 0) } # [doc = "Bit 22 - Selects the polarity of an event on input pin RTC_EV2."] # [inline (always)] pub fn pol2 (& self) -> Pol2R { Pol2R :: new (((self . bits >> 22) & 1) != 0) } # [doc = "Bit 23 - Event enable control for channel 2.\\[1\\]"] # [inline (always)] pub fn ev2_input_en (& self) -> Ev2InputEnR { Ev2InputEnR :: new (((self . bits >> 23) & 1) != 0) } # [doc = "Bits 30:31 - Controls enabling the Event Monitor/Recorder and selecting its operating frequency.\\[2\\]"] # [inline (always)] pub fn ermode (& self) -> ErmodeR { ErmodeR :: new (((self . bits >> 30) & 3) as u8) } } impl W { # [doc = "Bit 0 - Interrupt and wakeup enable for channel 0."] # [inline (always)] pub fn intwake_en0 (& mut self) -> IntwakeEn0W < '_ , ErcontrolSpec > { IntwakeEn0W :: new (self , 0) } # [doc = "Bit 1 - Enables automatically clearing the RTC general purpose registers when an event occurs on channel 0."] # [inline (always)] pub fn gpclear_en0 (& mut self) -> GpclearEn0W < '_ , ErcontrolSpec > { GpclearEn0W :: new (self , 1) } # [doc = "Bit 2 - Selects the polarity of an event on input pin RTC_EV0."] # [inline (always)] pub fn pol0 (& mut self) -> Pol0W < '_ , ErcontrolSpec > { Pol0W :: new (self , 2) } # [doc = "Bit 3 - Event enable control for channel 0.\\[1\\]"] # [inline (always)] pub fn ev0_input_en (& mut self) -> Ev0InputEnW < '_ , ErcontrolSpec > { Ev0InputEnW :: new (self , 3) } # [doc = "Bit 10 - Interrupt and wakeup enable for channel 1."] # [inline (always)] pub fn intwake_en1 (& mut self) -> IntwakeEn1W < '_ , ErcontrolSpec > { IntwakeEn1W :: new (self , 10) } # [doc = "Bit 11 - Enables automatically clearing the RTC general purpose registers when an event occurs on channel 1."] # [inline (always)] pub fn gpclear_en1 (& mut self) -> GpclearEn1W < '_ , ErcontrolSpec > { GpclearEn1W :: new (self , 11) } # [doc = "Bit 12 - Selects the polarity of an event on input pin RTC_EV1."] # [inline (always)] pub fn pol1 (& mut self) -> Pol1W < '_ , ErcontrolSpec > { Pol1W :: new (self , 12) } # [doc = "Bit 13 - Event enable control for channel 1.\\[1\\]"] # [inline (always)] pub fn ev1_input_en (& mut self) -> Ev1InputEnW < '_ , ErcontrolSpec > { Ev1InputEnW :: new (self , 13) } # [doc = "Bit 20 - Interrupt and wakeup enable for channel 2."] # [inline (always)] pub fn intwake_en2 (& mut self) -> IntwakeEn2W < '_ , ErcontrolSpec > { IntwakeEn2W :: new (self , 20) } # [doc = "Bit 21 - Enables automatically clearing the RTC general purpose registers when an event occurs on channel 2."] # [inline (always)] pub fn gpclear_en2 (& mut self) -> GpclearEn2W < '_ , ErcontrolSpec > { GpclearEn2W :: new (self , 21) } # [doc = "Bit 22 - Selects the polarity of an event on input pin RTC_EV2."] # [inline (always)] pub fn pol2 (& mut self) -> Pol2W < '_ , ErcontrolSpec > { Pol2W :: new (self , 22) } # [doc = "Bit 23 - Event enable control for channel 2.\\[1\\]"] # [inline (always)] pub fn ev2_input_en (& mut self) -> Ev2InputEnW < '_ , ErcontrolSpec > { Ev2InputEnW :: new (self , 23) } # [doc = "Bits 30:31 - Controls enabling the Event Monitor/Recorder and selecting its operating frequency.\\[2\\]"] # [inline (always)] pub fn ermode (& mut self) -> ErmodeW < '_ , ErcontrolSpec > { ErmodeW :: new (self , 30) } } # [doc = "Event Monitor/Recorder Control register. Contains bits that control actions for the event channels as well as for Event Monitor/Recorder setup.\n\nYou can [`read`](crate::Reg::read) this register and get [`ercontrol::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ercontrol::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct ErcontrolSpec ; impl crate :: RegisterSpec for ErcontrolSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ercontrol::R`](R) reader structure"] impl crate :: Readable for ErcontrolSpec { } # [doc = "`write(|w| ..)` method takes [`ercontrol::W`](W) writer structure"] impl crate :: Writable for ErcontrolSpec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets ERCONTROL to value 0"] impl crate :: Resettable for ErcontrolSpec { }