#[doc = "Register `ERCONTROL` reader"]
pub type R = crate::R<ErcontrolSpec>;
#[doc = "Register `ERCONTROL` writer"]
pub type W = crate::W<ErcontrolSpec>;
#[doc = "Interrupt and wakeup enable for channel 0.\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum IntwakeEn0 {
    #[doc = "0: No interrupt or wakeup will be generated by event channel 0."]
    Disabled = 0,
    #[doc = "1: An event in channel 0 will trigger an (RTC) interrupt and a wake-up request."]
    Enabled = 1,
}
impl From<IntwakeEn0> for bool {
    #[inline(always)]
    fn from(variant: IntwakeEn0) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `INTWAKE_EN0` reader - Interrupt and wakeup enable for channel 0."]
pub type IntwakeEn0R = crate::BitReader<IntwakeEn0>;
impl IntwakeEn0R {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> IntwakeEn0 {
        match self.bits {
            false => IntwakeEn0::Disabled,
            true => IntwakeEn0::Enabled,
        }
    }
    #[doc = "No interrupt or wakeup will be generated by event channel 0."]
    #[inline(always)]
    pub fn is_disabled(&self) -> bool {
        *self == IntwakeEn0::Disabled
    }
    #[doc = "An event in channel 0 will trigger an (RTC) interrupt and a wake-up request."]
    #[inline(always)]
    pub fn is_enabled(&self) -> bool {
        *self == IntwakeEn0::Enabled
    }
}
#[doc = "Field `INTWAKE_EN0` writer - Interrupt and wakeup enable for channel 0."]
pub type IntwakeEn0W<'a, REG> = crate::BitWriter<'a, REG, IntwakeEn0>;
impl<'a, REG> IntwakeEn0W<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "No interrupt or wakeup will be generated by event channel 0."]
    #[inline(always)]
    pub fn disabled(self) -> &'a mut crate::W<REG> {
        self.variant(IntwakeEn0::Disabled)
    }
    #[doc = "An event in channel 0 will trigger an (RTC) interrupt and a wake-up request."]
    #[inline(always)]
    pub fn enabled(self) -> &'a mut crate::W<REG> {
        self.variant(IntwakeEn0::Enabled)
    }
}
#[doc = "Enables automatically clearing the RTC general purpose registers when an event occurs on channel 0.\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum GpclearEn0 {
    #[doc = "0: Channel 0 has no influence on the general purpose registers."]
    Nogpreg = 0,
    #[doc = "1: An event in channel 0 will clear the general purpose registers asynchronously."]
    Clrgpreg = 1,
}
impl From<GpclearEn0> for bool {
    #[inline(always)]
    fn from(variant: GpclearEn0) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `GPCLEAR_EN0` reader - Enables automatically clearing the RTC general purpose registers when an event occurs on channel 0."]
pub type GpclearEn0R = crate::BitReader<GpclearEn0>;
impl GpclearEn0R {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> GpclearEn0 {
        match self.bits {
            false => GpclearEn0::Nogpreg,
            true => GpclearEn0::Clrgpreg,
        }
    }
    #[doc = "Channel 0 has no influence on the general purpose registers."]
    #[inline(always)]
    pub fn is_nogpreg(&self) -> bool {
        *self == GpclearEn0::Nogpreg
    }
    #[doc = "An event in channel 0 will clear the general purpose registers asynchronously."]
    #[inline(always)]
    pub fn is_clrgpreg(&self) -> bool {
        *self == GpclearEn0::Clrgpreg
    }
}
#[doc = "Field `GPCLEAR_EN0` writer - Enables automatically clearing the RTC general purpose registers when an event occurs on channel 0."]
pub type GpclearEn0W<'a, REG> = crate::BitWriter<'a, REG, GpclearEn0>;
impl<'a, REG> GpclearEn0W<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "Channel 0 has no influence on the general purpose registers."]
    #[inline(always)]
    pub fn nogpreg(self) -> &'a mut crate::W<REG> {
        self.variant(GpclearEn0::Nogpreg)
    }
    #[doc = "An event in channel 0 will clear the general purpose registers asynchronously."]
    #[inline(always)]
    pub fn clrgpreg(self) -> &'a mut crate::W<REG> {
        self.variant(GpclearEn0::Clrgpreg)
    }
}
#[doc = "Selects the polarity of an event on input pin RTC_EV0.\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Pol0 {
    #[doc = "0: A channel 0 event is defined as a negative edge on RTC_EV0."]
    Neg = 0,
    #[doc = "1: A channel 0 event is defined as a positive edge on RTC_EV0."]
    Pos = 1,
}
impl From<Pol0> for bool {
    #[inline(always)]
    fn from(variant: Pol0) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `POL0` reader - Selects the polarity of an event on input pin RTC_EV0."]
pub type Pol0R = crate::BitReader<Pol0>;
impl Pol0R {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> Pol0 {
        match self.bits {
            false => Pol0::Neg,
            true => Pol0::Pos,
        }
    }
    #[doc = "A channel 0 event is defined as a negative edge on RTC_EV0."]
    #[inline(always)]
    pub fn is_neg(&self) -> bool {
        *self == Pol0::Neg
    }
    #[doc = "A channel 0 event is defined as a positive edge on RTC_EV0."]
    #[inline(always)]
    pub fn is_pos(&self) -> bool {
        *self == Pol0::Pos
    }
}
#[doc = "Field `POL0` writer - Selects the polarity of an event on input pin RTC_EV0."]
pub type Pol0W<'a, REG> = crate::BitWriter<'a, REG, Pol0>;
impl<'a, REG> Pol0W<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "A channel 0 event is defined as a negative edge on RTC_EV0."]
    #[inline(always)]
    pub fn neg(self) -> &'a mut crate::W<REG> {
        self.variant(Pol0::Neg)
    }
    #[doc = "A channel 0 event is defined as a positive edge on RTC_EV0."]
    #[inline(always)]
    pub fn pos(self) -> &'a mut crate::W<REG> {
        self.variant(Pol0::Pos)
    }
}
#[doc = "Event enable control for channel 0.\\[1\\]\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Ev0InputEn {
    #[doc = "0: Event 0 input is disabled and forced high internally."]
    Disabled = 0,
    #[doc = "1: Event 0 input is enabled."]
    Enabled = 1,
}
impl From<Ev0InputEn> for bool {
    #[inline(always)]
    fn from(variant: Ev0InputEn) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `EV0_INPUT_EN` reader - Event enable control for channel 0.\\[1\\]"]
pub type Ev0InputEnR = crate::BitReader<Ev0InputEn>;
impl Ev0InputEnR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> Ev0InputEn {
        match self.bits {
            false => Ev0InputEn::Disabled,
            true => Ev0InputEn::Enabled,
        }
    }
    #[doc = "Event 0 input is disabled and forced high internally."]
    #[inline(always)]
    pub fn is_disabled(&self) -> bool {
        *self == Ev0InputEn::Disabled
    }
    #[doc = "Event 0 input is enabled."]
    #[inline(always)]
    pub fn is_enabled(&self) -> bool {
        *self == Ev0InputEn::Enabled
    }
}
#[doc = "Field `EV0_INPUT_EN` writer - Event enable control for channel 0.\\[1\\]"]
pub type Ev0InputEnW<'a, REG> = crate::BitWriter<'a, REG, Ev0InputEn>;
impl<'a, REG> Ev0InputEnW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "Event 0 input is disabled and forced high internally."]
    #[inline(always)]
    pub fn disabled(self) -> &'a mut crate::W<REG> {
        self.variant(Ev0InputEn::Disabled)
    }
    #[doc = "Event 0 input is enabled."]
    #[inline(always)]
    pub fn enabled(self) -> &'a mut crate::W<REG> {
        self.variant(Ev0InputEn::Enabled)
    }
}
#[doc = "Interrupt and wakeup enable for channel 1.\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum IntwakeEn1 {
    #[doc = "0: No interrupt or wakeup will be generated by event channel 1."]
    Disabled = 0,
    #[doc = "1: An event in channel 1 will trigger an (RTC) interrupt and a wake-up request."]
    Wakeup = 1,
}
impl From<IntwakeEn1> for bool {
    #[inline(always)]
    fn from(variant: IntwakeEn1) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `INTWAKE_EN1` reader - Interrupt and wakeup enable for channel 1."]
pub type IntwakeEn1R = crate::BitReader<IntwakeEn1>;
impl IntwakeEn1R {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> IntwakeEn1 {
        match self.bits {
            false => IntwakeEn1::Disabled,
            true => IntwakeEn1::Wakeup,
        }
    }
    #[doc = "No interrupt or wakeup will be generated by event channel 1."]
    #[inline(always)]
    pub fn is_disabled(&self) -> bool {
        *self == IntwakeEn1::Disabled
    }
    #[doc = "An event in channel 1 will trigger an (RTC) interrupt and a wake-up request."]
    #[inline(always)]
    pub fn is_wakeup(&self) -> bool {
        *self == IntwakeEn1::Wakeup
    }
}
#[doc = "Field `INTWAKE_EN1` writer - Interrupt and wakeup enable for channel 1."]
pub type IntwakeEn1W<'a, REG> = crate::BitWriter<'a, REG, IntwakeEn1>;
impl<'a, REG> IntwakeEn1W<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "No interrupt or wakeup will be generated by event channel 1."]
    #[inline(always)]
    pub fn disabled(self) -> &'a mut crate::W<REG> {
        self.variant(IntwakeEn1::Disabled)
    }
    #[doc = "An event in channel 1 will trigger an (RTC) interrupt and a wake-up request."]
    #[inline(always)]
    pub fn wakeup(self) -> &'a mut crate::W<REG> {
        self.variant(IntwakeEn1::Wakeup)
    }
}
#[doc = "Enables automatically clearing the RTC general purpose registers when an event occurs on channel 1.\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum GpclearEn1 {
    #[doc = "0: Channel 1 has no influence on the general purpose registers."]
    Nogpreg = 0,
    #[doc = "1: A n event in channel 1 will clear the general purpose registers asynchronously."]
    Clrgpreg = 1,
}
impl From<GpclearEn1> for bool {
    #[inline(always)]
    fn from(variant: GpclearEn1) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `GPCLEAR_EN1` reader - Enables automatically clearing the RTC general purpose registers when an event occurs on channel 1."]
pub type GpclearEn1R = crate::BitReader<GpclearEn1>;
impl GpclearEn1R {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> GpclearEn1 {
        match self.bits {
            false => GpclearEn1::Nogpreg,
            true => GpclearEn1::Clrgpreg,
        }
    }
    #[doc = "Channel 1 has no influence on the general purpose registers."]
    #[inline(always)]
    pub fn is_nogpreg(&self) -> bool {
        *self == GpclearEn1::Nogpreg
    }
    #[doc = "A n event in channel 1 will clear the general purpose registers asynchronously."]
    #[inline(always)]
    pub fn is_clrgpreg(&self) -> bool {
        *self == GpclearEn1::Clrgpreg
    }
}
#[doc = "Field `GPCLEAR_EN1` writer - Enables automatically clearing the RTC general purpose registers when an event occurs on channel 1."]
pub type GpclearEn1W<'a, REG> = crate::BitWriter<'a, REG, GpclearEn1>;
impl<'a, REG> GpclearEn1W<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "Channel 1 has no influence on the general purpose registers."]
    #[inline(always)]
    pub fn nogpreg(self) -> &'a mut crate::W<REG> {
        self.variant(GpclearEn1::Nogpreg)
    }
    #[doc = "A n event in channel 1 will clear the general purpose registers asynchronously."]
    #[inline(always)]
    pub fn clrgpreg(self) -> &'a mut crate::W<REG> {
        self.variant(GpclearEn1::Clrgpreg)
    }
}
#[doc = "Selects the polarity of an event on input pin RTC_EV1.\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Pol1 {
    #[doc = "0: A channel 1 event is defined as a negative edge on RTC_EV1."]
    Neg = 0,
    #[doc = "1: A channel 1 event is defined as a positive edge on RTC_EV1."]
    Pos = 1,
}
impl From<Pol1> for bool {
    #[inline(always)]
    fn from(variant: Pol1) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `POL1` reader - Selects the polarity of an event on input pin RTC_EV1."]
pub type Pol1R = crate::BitReader<Pol1>;
impl Pol1R {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> Pol1 {
        match self.bits {
            false => Pol1::Neg,
            true => Pol1::Pos,
        }
    }
    #[doc = "A channel 1 event is defined as a negative edge on RTC_EV1."]
    #[inline(always)]
    pub fn is_neg(&self) -> bool {
        *self == Pol1::Neg
    }
    #[doc = "A channel 1 event is defined as a positive edge on RTC_EV1."]
    #[inline(always)]
    pub fn is_pos(&self) -> bool {
        *self == Pol1::Pos
    }
}
#[doc = "Field `POL1` writer - Selects the polarity of an event on input pin RTC_EV1."]
pub type Pol1W<'a, REG> = crate::BitWriter<'a, REG, Pol1>;
impl<'a, REG> Pol1W<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "A channel 1 event is defined as a negative edge on RTC_EV1."]
    #[inline(always)]
    pub fn neg(self) -> &'a mut crate::W<REG> {
        self.variant(Pol1::Neg)
    }
    #[doc = "A channel 1 event is defined as a positive edge on RTC_EV1."]
    #[inline(always)]
    pub fn pos(self) -> &'a mut crate::W<REG> {
        self.variant(Pol1::Pos)
    }
}
#[doc = "Event enable control for channel 1.\\[1\\]\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Ev1InputEn {
    #[doc = "0: Event 1 input is disabled and forced high internally."]
    Disabled = 0,
    #[doc = "1: Event 1 input is enabled."]
    Enabled = 1,
}
impl From<Ev1InputEn> for bool {
    #[inline(always)]
    fn from(variant: Ev1InputEn) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `EV1_INPUT_EN` reader - Event enable control for channel 1.\\[1\\]"]
pub type Ev1InputEnR = crate::BitReader<Ev1InputEn>;
impl Ev1InputEnR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> Ev1InputEn {
        match self.bits {
            false => Ev1InputEn::Disabled,
            true => Ev1InputEn::Enabled,
        }
    }
    #[doc = "Event 1 input is disabled and forced high internally."]
    #[inline(always)]
    pub fn is_disabled(&self) -> bool {
        *self == Ev1InputEn::Disabled
    }
    #[doc = "Event 1 input is enabled."]
    #[inline(always)]
    pub fn is_enabled(&self) -> bool {
        *self == Ev1InputEn::Enabled
    }
}
#[doc = "Field `EV1_INPUT_EN` writer - Event enable control for channel 1.\\[1\\]"]
pub type Ev1InputEnW<'a, REG> = crate::BitWriter<'a, REG, Ev1InputEn>;
impl<'a, REG> Ev1InputEnW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "Event 1 input is disabled and forced high internally."]
    #[inline(always)]
    pub fn disabled(self) -> &'a mut crate::W<REG> {
        self.variant(Ev1InputEn::Disabled)
    }
    #[doc = "Event 1 input is enabled."]
    #[inline(always)]
    pub fn enabled(self) -> &'a mut crate::W<REG> {
        self.variant(Ev1InputEn::Enabled)
    }
}
#[doc = "Interrupt and wakeup enable for channel 2.\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum IntwakeEn2 {
    #[doc = "0: No interrupt or wakeup will be generated by event channel 2."]
    Disabled = 0,
    #[doc = "1: An event in channel 2 will trigger an (RTC) interrupt and a wake-up request."]
    Wakeup = 1,
}
impl From<IntwakeEn2> for bool {
    #[inline(always)]
    fn from(variant: IntwakeEn2) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `INTWAKE_EN2` reader - Interrupt and wakeup enable for channel 2."]
pub type IntwakeEn2R = crate::BitReader<IntwakeEn2>;
impl IntwakeEn2R {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> IntwakeEn2 {
        match self.bits {
            false => IntwakeEn2::Disabled,
            true => IntwakeEn2::Wakeup,
        }
    }
    #[doc = "No interrupt or wakeup will be generated by event channel 2."]
    #[inline(always)]
    pub fn is_disabled(&self) -> bool {
        *self == IntwakeEn2::Disabled
    }
    #[doc = "An event in channel 2 will trigger an (RTC) interrupt and a wake-up request."]
    #[inline(always)]
    pub fn is_wakeup(&self) -> bool {
        *self == IntwakeEn2::Wakeup
    }
}
#[doc = "Field `INTWAKE_EN2` writer - Interrupt and wakeup enable for channel 2."]
pub type IntwakeEn2W<'a, REG> = crate::BitWriter<'a, REG, IntwakeEn2>;
impl<'a, REG> IntwakeEn2W<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "No interrupt or wakeup will be generated by event channel 2."]
    #[inline(always)]
    pub fn disabled(self) -> &'a mut crate::W<REG> {
        self.variant(IntwakeEn2::Disabled)
    }
    #[doc = "An event in channel 2 will trigger an (RTC) interrupt and a wake-up request."]
    #[inline(always)]
    pub fn wakeup(self) -> &'a mut crate::W<REG> {
        self.variant(IntwakeEn2::Wakeup)
    }
}
#[doc = "Enables automatically clearing the RTC general purpose registers when an event occurs on channel 2.\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum GpclearEn2 {
    #[doc = "0: Channel 2 has no influence on the general purpose registers."]
    Nogpreg = 0,
    #[doc = "1: An event in channel 2 will clear the general purpose registers asynchronously."]
    Clrgpreg = 1,
}
impl From<GpclearEn2> for bool {
    #[inline(always)]
    fn from(variant: GpclearEn2) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `GPCLEAR_EN2` reader - Enables automatically clearing the RTC general purpose registers when an event occurs on channel 2."]
pub type GpclearEn2R = crate::BitReader<GpclearEn2>;
impl GpclearEn2R {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> GpclearEn2 {
        match self.bits {
            false => GpclearEn2::Nogpreg,
            true => GpclearEn2::Clrgpreg,
        }
    }
    #[doc = "Channel 2 has no influence on the general purpose registers."]
    #[inline(always)]
    pub fn is_nogpreg(&self) -> bool {
        *self == GpclearEn2::Nogpreg
    }
    #[doc = "An event in channel 2 will clear the general purpose registers asynchronously."]
    #[inline(always)]
    pub fn is_clrgpreg(&self) -> bool {
        *self == GpclearEn2::Clrgpreg
    }
}
#[doc = "Field `GPCLEAR_EN2` writer - Enables automatically clearing the RTC general purpose registers when an event occurs on channel 2."]
pub type GpclearEn2W<'a, REG> = crate::BitWriter<'a, REG, GpclearEn2>;
impl<'a, REG> GpclearEn2W<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "Channel 2 has no influence on the general purpose registers."]
    #[inline(always)]
    pub fn nogpreg(self) -> &'a mut crate::W<REG> {
        self.variant(GpclearEn2::Nogpreg)
    }
    #[doc = "An event in channel 2 will clear the general purpose registers asynchronously."]
    #[inline(always)]
    pub fn clrgpreg(self) -> &'a mut crate::W<REG> {
        self.variant(GpclearEn2::Clrgpreg)
    }
}
#[doc = "Selects the polarity of an event on input pin RTC_EV2.\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Pol2 {
    #[doc = "0: A channel 2 event is defined as a negative edge on RTC_EV2."]
    Neg = 0,
    #[doc = "1: A channel 2 event is defined as a positive edge on RTC_EV2."]
    Pos = 1,
}
impl From<Pol2> for bool {
    #[inline(always)]
    fn from(variant: Pol2) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `POL2` reader - Selects the polarity of an event on input pin RTC_EV2."]
pub type Pol2R = crate::BitReader<Pol2>;
impl Pol2R {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> Pol2 {
        match self.bits {
            false => Pol2::Neg,
            true => Pol2::Pos,
        }
    }
    #[doc = "A channel 2 event is defined as a negative edge on RTC_EV2."]
    #[inline(always)]
    pub fn is_neg(&self) -> bool {
        *self == Pol2::Neg
    }
    #[doc = "A channel 2 event is defined as a positive edge on RTC_EV2."]
    #[inline(always)]
    pub fn is_pos(&self) -> bool {
        *self == Pol2::Pos
    }
}
#[doc = "Field `POL2` writer - Selects the polarity of an event on input pin RTC_EV2."]
pub type Pol2W<'a, REG> = crate::BitWriter<'a, REG, Pol2>;
impl<'a, REG> Pol2W<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "A channel 2 event is defined as a negative edge on RTC_EV2."]
    #[inline(always)]
    pub fn neg(self) -> &'a mut crate::W<REG> {
        self.variant(Pol2::Neg)
    }
    #[doc = "A channel 2 event is defined as a positive edge on RTC_EV2."]
    #[inline(always)]
    pub fn pos(self) -> &'a mut crate::W<REG> {
        self.variant(Pol2::Pos)
    }
}
#[doc = "Event enable control for channel 2.\\[1\\]\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Ev2InputEn {
    #[doc = "0: Event 2 input is disabled and forced high internally."]
    Disabled = 0,
    #[doc = "1: Event 2 input is enabled."]
    Enabled = 1,
}
impl From<Ev2InputEn> for bool {
    #[inline(always)]
    fn from(variant: Ev2InputEn) -> Self {
        variant as u8 != 0
    }
}
#[doc = "Field `EV2_INPUT_EN` reader - Event enable control for channel 2.\\[1\\]"]
pub type Ev2InputEnR = crate::BitReader<Ev2InputEn>;
impl Ev2InputEnR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> Ev2InputEn {
        match self.bits {
            false => Ev2InputEn::Disabled,
            true => Ev2InputEn::Enabled,
        }
    }
    #[doc = "Event 2 input is disabled and forced high internally."]
    #[inline(always)]
    pub fn is_disabled(&self) -> bool {
        *self == Ev2InputEn::Disabled
    }
    #[doc = "Event 2 input is enabled."]
    #[inline(always)]
    pub fn is_enabled(&self) -> bool {
        *self == Ev2InputEn::Enabled
    }
}
#[doc = "Field `EV2_INPUT_EN` writer - Event enable control for channel 2.\\[1\\]"]
pub type Ev2InputEnW<'a, REG> = crate::BitWriter<'a, REG, Ev2InputEn>;
impl<'a, REG> Ev2InputEnW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
{
    #[doc = "Event 2 input is disabled and forced high internally."]
    #[inline(always)]
    pub fn disabled(self) -> &'a mut crate::W<REG> {
        self.variant(Ev2InputEn::Disabled)
    }
    #[doc = "Event 2 input is enabled."]
    #[inline(always)]
    pub fn enabled(self) -> &'a mut crate::W<REG> {
        self.variant(Ev2InputEn::Enabled)
    }
}
#[doc = "Controls enabling the Event Monitor/Recorder and selecting its operating frequency.\\[2\\]\n\nValue on reset: 0"]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[repr(u8)]
pub enum Ermode {
    #[doc = "0: Event Monitor/Recorder clocks are disabled. Operation of the Event Monitor/Recorder is disabled except for asynchronous clearing of GP registers if selected."]
    Disabled = 0,
    #[doc = "1: Enable Event Monitor/Recorder and select a 16 Hz sample clock for event input edge detection and glitch suppression. Pulses (in either direction) shorter than 62.5 ms to 125 ms will be filtered out."]
    EnableEventMonitor16hz = 1,
    #[doc = "2: Enable Event Monitor/Recorder and select a 64 Hz sample clock for event input edge detection and glitch suppression. Pulses (in either direction) shorter than 15.6 ms to 31.2 ms will be filtered out."]
    EnableEventMonitor64hz = 2,
    #[doc = "3: Enable Event Monitor/Recorder and select a 1 kHz sample clock for event input edge detection and glitch suppression. Pulses (in either direction) shorter than 1 ms to 2 ms will be filtered out."]
    EnableEventMonitor1khz = 3,
}
impl From<Ermode> for u8 {
    #[inline(always)]
    fn from(variant: Ermode) -> Self {
        variant as _
    }
}
impl crate::FieldSpec for Ermode {
    type Ux = u8;
}
impl crate::IsEnum for Ermode {}
#[doc = "Field `ERMODE` reader - Controls enabling the Event Monitor/Recorder and selecting its operating frequency.\\[2\\]"]
pub type ErmodeR = crate::FieldReader<Ermode>;
impl ErmodeR {
    #[doc = "Get enumerated values variant"]
    #[inline(always)]
    pub const fn variant(&self) -> Ermode {
        match self.bits {
            0 => Ermode::Disabled,
            1 => Ermode::EnableEventMonitor16hz,
            2 => Ermode::EnableEventMonitor64hz,
            3 => Ermode::EnableEventMonitor1khz,
            _ => unreachable!(),
        }
    }
    #[doc = "Event Monitor/Recorder clocks are disabled. Operation of the Event Monitor/Recorder is disabled except for asynchronous clearing of GP registers if selected."]
    #[inline(always)]
    pub fn is_disabled(&self) -> bool {
        *self == Ermode::Disabled
    }
    #[doc = "Enable Event Monitor/Recorder and select a 16 Hz sample clock for event input edge detection and glitch suppression. Pulses (in either direction) shorter than 62.5 ms to 125 ms will be filtered out."]
    #[inline(always)]
    pub fn is_enable_event_monitor16hz(&self) -> bool {
        *self == Ermode::EnableEventMonitor16hz
    }
    #[doc = "Enable Event Monitor/Recorder and select a 64 Hz sample clock for event input edge detection and glitch suppression. Pulses (in either direction) shorter than 15.6 ms to 31.2 ms will be filtered out."]
    #[inline(always)]
    pub fn is_enable_event_monitor64hz(&self) -> bool {
        *self == Ermode::EnableEventMonitor64hz
    }
    #[doc = "Enable Event Monitor/Recorder and select a 1 kHz sample clock for event input edge detection and glitch suppression. Pulses (in either direction) shorter than 1 ms to 2 ms will be filtered out."]
    #[inline(always)]
    pub fn is_enable_event_monitor1khz(&self) -> bool {
        *self == Ermode::EnableEventMonitor1khz
    }
}
#[doc = "Field `ERMODE` writer - Controls enabling the Event Monitor/Recorder and selecting its operating frequency.\\[2\\]"]
pub type ErmodeW<'a, REG> = crate::FieldWriter<'a, REG, 2, Ermode, crate::Safe>;
impl<'a, REG> ErmodeW<'a, REG>
where
    REG: crate::Writable + crate::RegisterSpec,
    REG::Ux: From<u8>,
{
    #[doc = "Event Monitor/Recorder clocks are disabled. Operation of the Event Monitor/Recorder is disabled except for asynchronous clearing of GP registers if selected."]
    #[inline(always)]
    pub fn disabled(self) -> &'a mut crate::W<REG> {
        self.variant(Ermode::Disabled)
    }
    #[doc = "Enable Event Monitor/Recorder and select a 16 Hz sample clock for event input edge detection and glitch suppression. Pulses (in either direction) shorter than 62.5 ms to 125 ms will be filtered out."]
    #[inline(always)]
    pub fn enable_event_monitor16hz(self) -> &'a mut crate::W<REG> {
        self.variant(Ermode::EnableEventMonitor16hz)
    }
    #[doc = "Enable Event Monitor/Recorder and select a 64 Hz sample clock for event input edge detection and glitch suppression. Pulses (in either direction) shorter than 15.6 ms to 31.2 ms will be filtered out."]
    #[inline(always)]
    pub fn enable_event_monitor64hz(self) -> &'a mut crate::W<REG> {
        self.variant(Ermode::EnableEventMonitor64hz)
    }
    #[doc = "Enable Event Monitor/Recorder and select a 1 kHz sample clock for event input edge detection and glitch suppression. Pulses (in either direction) shorter than 1 ms to 2 ms will be filtered out."]
    #[inline(always)]
    pub fn enable_event_monitor1khz(self) -> &'a mut crate::W<REG> {
        self.variant(Ermode::EnableEventMonitor1khz)
    }
}
impl R {
    #[doc = "Bit 0 - Interrupt and wakeup enable for channel 0."]
    #[inline(always)]
    pub fn intwake_en0(&self) -> IntwakeEn0R {
        IntwakeEn0R::new((self.bits & 1) != 0)
    }
    #[doc = "Bit 1 - Enables automatically clearing the RTC general purpose registers when an event occurs on channel 0."]
    #[inline(always)]
    pub fn gpclear_en0(&self) -> GpclearEn0R {
        GpclearEn0R::new(((self.bits >> 1) & 1) != 0)
    }
    #[doc = "Bit 2 - Selects the polarity of an event on input pin RTC_EV0."]
    #[inline(always)]
    pub fn pol0(&self) -> Pol0R {
        Pol0R::new(((self.bits >> 2) & 1) != 0)
    }
    #[doc = "Bit 3 - Event enable control for channel 0.\\[1\\]"]
    #[inline(always)]
    pub fn ev0_input_en(&self) -> Ev0InputEnR {
        Ev0InputEnR::new(((self.bits >> 3) & 1) != 0)
    }
    #[doc = "Bit 10 - Interrupt and wakeup enable for channel 1."]
    #[inline(always)]
    pub fn intwake_en1(&self) -> IntwakeEn1R {
        IntwakeEn1R::new(((self.bits >> 10) & 1) != 0)
    }
    #[doc = "Bit 11 - Enables automatically clearing the RTC general purpose registers when an event occurs on channel 1."]
    #[inline(always)]
    pub fn gpclear_en1(&self) -> GpclearEn1R {
        GpclearEn1R::new(((self.bits >> 11) & 1) != 0)
    }
    #[doc = "Bit 12 - Selects the polarity of an event on input pin RTC_EV1."]
    #[inline(always)]
    pub fn pol1(&self) -> Pol1R {
        Pol1R::new(((self.bits >> 12) & 1) != 0)
    }
    #[doc = "Bit 13 - Event enable control for channel 1.\\[1\\]"]
    #[inline(always)]
    pub fn ev1_input_en(&self) -> Ev1InputEnR {
        Ev1InputEnR::new(((self.bits >> 13) & 1) != 0)
    }
    #[doc = "Bit 20 - Interrupt and wakeup enable for channel 2."]
    #[inline(always)]
    pub fn intwake_en2(&self) -> IntwakeEn2R {
        IntwakeEn2R::new(((self.bits >> 20) & 1) != 0)
    }
    #[doc = "Bit 21 - Enables automatically clearing the RTC general purpose registers when an event occurs on channel 2."]
    #[inline(always)]
    pub fn gpclear_en2(&self) -> GpclearEn2R {
        GpclearEn2R::new(((self.bits >> 21) & 1) != 0)
    }
    #[doc = "Bit 22 - Selects the polarity of an event on input pin RTC_EV2."]
    #[inline(always)]
    pub fn pol2(&self) -> Pol2R {
        Pol2R::new(((self.bits >> 22) & 1) != 0)
    }
    #[doc = "Bit 23 - Event enable control for channel 2.\\[1\\]"]
    #[inline(always)]
    pub fn ev2_input_en(&self) -> Ev2InputEnR {
        Ev2InputEnR::new(((self.bits >> 23) & 1) != 0)
    }
    #[doc = "Bits 30:31 - Controls enabling the Event Monitor/Recorder and selecting its operating frequency.\\[2\\]"]
    #[inline(always)]
    pub fn ermode(&self) -> ErmodeR {
        ErmodeR::new(((self.bits >> 30) & 3) as u8)
    }
}
impl W {
    #[doc = "Bit 0 - Interrupt and wakeup enable for channel 0."]
    #[inline(always)]
    pub fn intwake_en0(&mut self) -> IntwakeEn0W<'_, ErcontrolSpec> {
        IntwakeEn0W::new(self, 0)
    }
    #[doc = "Bit 1 - Enables automatically clearing the RTC general purpose registers when an event occurs on channel 0."]
    #[inline(always)]
    pub fn gpclear_en0(&mut self) -> GpclearEn0W<'_, ErcontrolSpec> {
        GpclearEn0W::new(self, 1)
    }
    #[doc = "Bit 2 - Selects the polarity of an event on input pin RTC_EV0."]
    #[inline(always)]
    pub fn pol0(&mut self) -> Pol0W<'_, ErcontrolSpec> {
        Pol0W::new(self, 2)
    }
    #[doc = "Bit 3 - Event enable control for channel 0.\\[1\\]"]
    #[inline(always)]
    pub fn ev0_input_en(&mut self) -> Ev0InputEnW<'_, ErcontrolSpec> {
        Ev0InputEnW::new(self, 3)
    }
    #[doc = "Bit 10 - Interrupt and wakeup enable for channel 1."]
    #[inline(always)]
    pub fn intwake_en1(&mut self) -> IntwakeEn1W<'_, ErcontrolSpec> {
        IntwakeEn1W::new(self, 10)
    }
    #[doc = "Bit 11 - Enables automatically clearing the RTC general purpose registers when an event occurs on channel 1."]
    #[inline(always)]
    pub fn gpclear_en1(&mut self) -> GpclearEn1W<'_, ErcontrolSpec> {
        GpclearEn1W::new(self, 11)
    }
    #[doc = "Bit 12 - Selects the polarity of an event on input pin RTC_EV1."]
    #[inline(always)]
    pub fn pol1(&mut self) -> Pol1W<'_, ErcontrolSpec> {
        Pol1W::new(self, 12)
    }
    #[doc = "Bit 13 - Event enable control for channel 1.\\[1\\]"]
    #[inline(always)]
    pub fn ev1_input_en(&mut self) -> Ev1InputEnW<'_, ErcontrolSpec> {
        Ev1InputEnW::new(self, 13)
    }
    #[doc = "Bit 20 - Interrupt and wakeup enable for channel 2."]
    #[inline(always)]
    pub fn intwake_en2(&mut self) -> IntwakeEn2W<'_, ErcontrolSpec> {
        IntwakeEn2W::new(self, 20)
    }
    #[doc = "Bit 21 - Enables automatically clearing the RTC general purpose registers when an event occurs on channel 2."]
    #[inline(always)]
    pub fn gpclear_en2(&mut self) -> GpclearEn2W<'_, ErcontrolSpec> {
        GpclearEn2W::new(self, 21)
    }
    #[doc = "Bit 22 - Selects the polarity of an event on input pin RTC_EV2."]
    #[inline(always)]
    pub fn pol2(&mut self) -> Pol2W<'_, ErcontrolSpec> {
        Pol2W::new(self, 22)
    }
    #[doc = "Bit 23 - Event enable control for channel 2.\\[1\\]"]
    #[inline(always)]
    pub fn ev2_input_en(&mut self) -> Ev2InputEnW<'_, ErcontrolSpec> {
        Ev2InputEnW::new(self, 23)
    }
    #[doc = "Bits 30:31 - Controls enabling the Event Monitor/Recorder and selecting its operating frequency.\\[2\\]"]
    #[inline(always)]
    pub fn ermode(&mut self) -> ErmodeW<'_, ErcontrolSpec> {
        ErmodeW::new(self, 30)
    }
}
#[doc = "Event Monitor/Recorder Control register. Contains bits that control actions for the event channels as well as for Event Monitor/Recorder setup.\n\nYou can [`read`](crate::Reg::read) this register and get [`ercontrol::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ercontrol::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ErcontrolSpec;
impl crate::RegisterSpec for ErcontrolSpec {
    type Ux = u32;
}
#[doc = "`read()` method returns [`ercontrol::R`](R) reader structure"]
impl crate::Readable for ErcontrolSpec {}
#[doc = "`write(|w| ..)` method takes [`ercontrol::W`](W) writer structure"]
impl crate::Writable for ErcontrolSpec {
    type Safety = crate::Unsafe;
}
#[doc = "`reset()` method sets ERCONTROL to value 0"]
impl crate::Resettable for ErcontrolSpec {}
