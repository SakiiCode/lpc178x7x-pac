# [doc = "Register `SYNCCTRL` reader"] pub type R = crate :: R < SyncctrlSpec > ; # [doc = "Register `SYNCCTRL` writer"] pub type W = crate :: W < SyncctrlSpec > ; # [doc = "Enables synchronous mode.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Enum { # [doc = "0: Disabled"] Disabled = 0 , # [doc = "1: Enabled"] Enabled = 1 , } impl From < Enum > for bool { # [inline (always)] fn from (variant : Enum) -> Self { variant as u8 != 0 } } # [doc = "Field `SYNC` reader - Enables synchronous mode."] pub type SyncR = crate :: BitReader < Enum > ; impl SyncR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Enum { match self . bits { false => Enum :: Disabled , true => Enum :: Enabled , } } # [doc = "Disabled"] # [inline (always)] pub fn is_disabled (& self) -> bool { * self == Enum :: Disabled } # [doc = "Enabled"] # [inline (always)] pub fn is_enabled (& self) -> bool { * self == Enum :: Enabled } } # [doc = "Field `SYNC` writer - Enables synchronous mode."] pub type SyncW < 'a , REG > = crate :: BitWriter < 'a , REG , Enum > ; impl < 'a , REG > SyncW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Disabled"] # [inline (always)] pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: Disabled) } # [doc = "Enabled"] # [inline (always)] pub fn enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: Enabled) } } # [doc = "Clock source select.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Enum { # [doc = "0: Synchronous slave mode (SCLK in)"] SynchronousSlaveMo = 0 , # [doc = "1: Synchronous master mode (SCLK out)"] SynchronousMasterM = 1 , } impl From < Enum > for bool { # [inline (always)] fn from (variant : Enum) -> Self { variant as u8 != 0 } } # [doc = "Field `CSRC` reader - Clock source select."] pub type CsrcR = crate :: BitReader < Enum > ; impl CsrcR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Enum { match self . bits { false => Enum :: SynchronousSlaveMo , true => Enum :: SynchronousMasterM , } } # [doc = "Synchronous slave mode (SCLK in)"] # [inline (always)] pub fn is_synchronous_slave_mo (& self) -> bool { * self == Enum :: SynchronousSlaveMo } # [doc = "Synchronous master mode (SCLK out)"] # [inline (always)] pub fn is_synchronous_master_m (& self) -> bool { * self == Enum :: SynchronousMasterM } } # [doc = "Field `CSRC` writer - Clock source select."] pub type CsrcW < 'a , REG > = crate :: BitWriter < 'a , REG , Enum > ; impl < 'a , REG > CsrcW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Synchronous slave mode (SCLK in)"] # [inline (always)] pub fn synchronous_slave_mo (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: SynchronousSlaveMo) } # [doc = "Synchronous master mode (SCLK out)"] # [inline (always)] pub fn synchronous_master_m (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: SynchronousMasterM) } } # [doc = "Falling edge sampling.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Enum { # [doc = "0: RxD is sampled on the rising edge of SCLK"] RxdIsSampledOnTh = 0 , # [doc = "1: RxD is sampled on the falling edge of SCLK"] RxdIsSampledOnTh = 1 , } impl From < Enum > for bool { # [inline (always)] fn from (variant : Enum) -> Self { variant as u8 != 0 } } # [doc = "Field `FES` reader - Falling edge sampling."] pub type FesR = crate :: BitReader < Enum > ; impl FesR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Enum { match self . bits { false => Enum :: RxdIsSampledOnTh , true => Enum :: RxdIsSampledOnTh , } } # [doc = "RxD is sampled on the rising edge of SCLK"] # [inline (always)] pub fn is_rxd_is_sampled_on_th (& self) -> bool { * self == Enum :: RxdIsSampledOnTh } # [doc = "RxD is sampled on the falling edge of SCLK"] # [inline (always)] pub fn is_rxd_is_sampled_on_th (& self) -> bool { * self == Enum :: RxdIsSampledOnTh } } # [doc = "Field `FES` writer - Falling edge sampling."] pub type FesW < 'a , REG > = crate :: BitWriter < 'a , REG , Enum > ; impl < 'a , REG > FesW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "RxD is sampled on the rising edge of SCLK"] # [inline (always)] pub fn rxd_is_sampled_on_th (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: RxdIsSampledOnTh) } # [doc = "RxD is sampled on the falling edge of SCLK"] # [inline (always)] pub fn rxd_is_sampled_on_th (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: RxdIsSampledOnTh) } } # [doc = "Transmit synchronization bypass in synchronous slave mode.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Enum { # [doc = "0: The input clock is synchronized prior to being used in clock edge detection logic."] TheInputClockIsS = 0 , # [doc = "1: The input clock is not synchronized prior to being used in clock edge detection logic. This allows for a high er input clock rate at the expense of potential metastability."] TheInputClockIsN = 1 , } impl From < Enum > for bool { # [inline (always)] fn from (variant : Enum) -> Self { variant as u8 != 0 } } # [doc = "Field `TSBYPASS` reader - Transmit synchronization bypass in synchronous slave mode."] pub type TsbypassR = crate :: BitReader < Enum > ; impl TsbypassR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Enum { match self . bits { false => Enum :: TheInputClockIsS , true => Enum :: TheInputClockIsN , } } # [doc = "The input clock is synchronized prior to being used in clock edge detection logic."] # [inline (always)] pub fn is_the_input_clock_is_s (& self) -> bool { * self == Enum :: TheInputClockIsS } # [doc = "The input clock is not synchronized prior to being used in clock edge detection logic. This allows for a high er input clock rate at the expense of potential metastability."] # [inline (always)] pub fn is_the_input_clock_is_n (& self) -> bool { * self == Enum :: TheInputClockIsN } } # [doc = "Field `TSBYPASS` writer - Transmit synchronization bypass in synchronous slave mode."] pub type TsbypassW < 'a , REG > = crate :: BitWriter < 'a , REG , Enum > ; impl < 'a , REG > TsbypassW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "The input clock is synchronized prior to being used in clock edge detection logic."] # [inline (always)] pub fn the_input_clock_is_s (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: TheInputClockIsS) } # [doc = "The input clock is not synchronized prior to being used in clock edge detection logic. This allows for a high er input clock rate at the expense of potential metastability."] # [inline (always)] pub fn the_input_clock_is_n (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: TheInputClockIsN) } } # [doc = "Continuous master clock enable (used only when CSRC is 1)\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Enum { # [doc = "0: SCLK cycles only when characters are being sent on TxD"] SclkCyclesOnlyWhe = 0 , # [doc = "1: SCLK runs continuously (characters can be received on RxD independently from transmission on TxD)"] SclkRunsContinuous = 1 , } impl From < Enum > for bool { # [inline (always)] fn from (variant : Enum) -> Self { variant as u8 != 0 } } # [doc = "Field `CSCEN` reader - Continuous master clock enable (used only when CSRC is 1)"] pub type CscenR = crate :: BitReader < Enum > ; impl CscenR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Enum { match self . bits { false => Enum :: SclkCyclesOnlyWhe , true => Enum :: SclkRunsContinuous , } } # [doc = "SCLK cycles only when characters are being sent on TxD"] # [inline (always)] pub fn is_sclk_cycles_only_whe (& self) -> bool { * self == Enum :: SclkCyclesOnlyWhe } # [doc = "SCLK runs continuously (characters can be received on RxD independently from transmission on TxD)"] # [inline (always)] pub fn is_sclk_runs_continuous (& self) -> bool { * self == Enum :: SclkRunsContinuous } } # [doc = "Field `CSCEN` writer - Continuous master clock enable (used only when CSRC is 1)"] pub type CscenW < 'a , REG > = crate :: BitWriter < 'a , REG , Enum > ; impl < 'a , REG > CscenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "SCLK cycles only when characters are being sent on TxD"] # [inline (always)] pub fn sclk_cycles_only_whe (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: SclkCyclesOnlyWhe) } # [doc = "SCLK runs continuously (characters can be received on RxD independently from transmission on TxD)"] # [inline (always)] pub fn sclk_runs_continuous (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: SclkRunsContinuous) } } # [doc = "Start/stop bits\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Enum { # [doc = "0: Send start and stop bits as in other modes."] SendStartAndStop_ = 0 , # [doc = "1: Do not send start/stop bits."] Nostartstopbit = 1 , } impl From < Enum > for bool { # [inline (always)] fn from (variant : Enum) -> Self { variant as u8 != 0 } } # [doc = "Field `SSSDIS` reader - Start/stop bits"] pub type SssdisR = crate :: BitReader < Enum > ; impl SssdisR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Enum { match self . bits { false => Enum :: SendStartAndStop_ , true => Enum :: Nostartstopbit , } } # [doc = "Send start and stop bits as in other modes."] # [inline (always)] pub fn is_send_start_and_stop_ (& self) -> bool { * self == Enum :: SendStartAndStop_ } # [doc = "Do not send start/stop bits."] # [inline (always)] pub fn is_nostartstopbit (& self) -> bool { * self == Enum :: Nostartstopbit } } # [doc = "Field `SSSDIS` writer - Start/stop bits"] pub type SssdisW < 'a , REG > = crate :: BitWriter < 'a , REG , Enum > ; impl < 'a , REG > SssdisW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Send start and stop bits as in other modes."] # [inline (always)] pub fn send_start_and_stop_ (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: SendStartAndStop_) } # [doc = "Do not send start/stop bits."] # [inline (always)] pub fn nostartstopbit (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: Nostartstopbit) } } # [doc = "Continuous clock clear\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Enum { # [doc = "0: CSCEN is under software control."] CscenIsUnderSoftw = 0 , # [doc = "1: Hardware clears CSCEN after each character is received."] HardwareClearsCsce = 1 , } impl From < Enum > for bool { # [inline (always)] fn from (variant : Enum) -> Self { variant as u8 != 0 } } # [doc = "Field `CCCLR` reader - Continuous clock clear"] pub type CcclrR = crate :: BitReader < Enum > ; impl CcclrR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Enum { match self . bits { false => Enum :: CscenIsUnderSoftw , true => Enum :: HardwareClearsCsce , } } # [doc = "CSCEN is under software control."] # [inline (always)] pub fn is_cscen_is_under_softw (& self) -> bool { * self == Enum :: CscenIsUnderSoftw } # [doc = "Hardware clears CSCEN after each character is received."] # [inline (always)] pub fn is_hardware_clears_csce (& self) -> bool { * self == Enum :: HardwareClearsCsce } } # [doc = "Field `CCCLR` writer - Continuous clock clear"] pub type CcclrW < 'a , REG > = crate :: BitWriter < 'a , REG , Enum > ; impl < 'a , REG > CcclrW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "CSCEN is under software control."] # [inline (always)] pub fn cscen_is_under_softw (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: CscenIsUnderSoftw) } # [doc = "Hardware clears CSCEN after each character is received."] # [inline (always)] pub fn hardware_clears_csce (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: HardwareClearsCsce) } } impl R { # [doc = "Bit 0 - Enables synchronous mode."] # [inline (always)] pub fn sync (& self) -> SyncR { SyncR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Clock source select."] # [inline (always)] pub fn csrc (& self) -> CsrcR { CsrcR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Falling edge sampling."] # [inline (always)] pub fn fes (& self) -> FesR { FesR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Transmit synchronization bypass in synchronous slave mode."] # [inline (always)] pub fn tsbypass (& self) -> TsbypassR { TsbypassR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Continuous master clock enable (used only when CSRC is 1)"] # [inline (always)] pub fn cscen (& self) -> CscenR { CscenR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Start/stop bits"] # [inline (always)] pub fn sssdis (& self) -> SssdisR { SssdisR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Continuous clock clear"] # [inline (always)] pub fn ccclr (& self) -> CcclrR { CcclrR :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - Enables synchronous mode."] # [inline (always)] pub fn sync (& mut self) -> SyncW < '_ , SyncctrlSpec > { SyncW :: new (self , 0) } # [doc = "Bit 1 - Clock source select."] # [inline (always)] pub fn csrc (& mut self) -> CsrcW < '_ , SyncctrlSpec > { CsrcW :: new (self , 1) } # [doc = "Bit 2 - Falling edge sampling."] # [inline (always)] pub fn fes (& mut self) -> FesW < '_ , SyncctrlSpec > { FesW :: new (self , 2) } # [doc = "Bit 3 - Transmit synchronization bypass in synchronous slave mode."] # [inline (always)] pub fn tsbypass (& mut self) -> TsbypassW < '_ , SyncctrlSpec > { TsbypassW :: new (self , 3) } # [doc = "Bit 4 - Continuous master clock enable (used only when CSRC is 1)"] # [inline (always)] pub fn cscen (& mut self) -> CscenW < '_ , SyncctrlSpec > { CscenW :: new (self , 4) } # [doc = "Bit 5 - Start/stop bits"] # [inline (always)] pub fn sssdis (& mut self) -> SssdisW < '_ , SyncctrlSpec > { SssdisW :: new (self , 5) } # [doc = "Bit 6 - Continuous clock clear"] # [inline (always)] pub fn ccclr (& mut self) -> CcclrW < '_ , SyncctrlSpec > { CcclrW :: new (self , 6) } } # [doc = "Synchronous mode control register.\n\nYou can [`read`](crate::Reg::read) this register and get [`syncctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`syncctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct SyncctrlSpec ; impl crate :: RegisterSpec for SyncctrlSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`syncctrl::R`](R) reader structure"] impl crate :: Readable for SyncctrlSpec { } # [doc = "`write(|w| ..)` method takes [`syncctrl::W`](W) writer structure"] impl crate :: Writable for SyncctrlSpec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets SYNCCTRL to value 0"] impl crate :: Resettable for SyncctrlSpec { }