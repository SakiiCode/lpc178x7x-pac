# [doc = "Register `CTRL` reader"] pub type R = crate :: R < CtrlSpec > ; # [doc = "Register `CTRL` writer"] pub type W = crate :: W < CtrlSpec > ; # [doc = "Field `LCDEN` reader - LCD enable control bit. 0 = LCD disabled. Signals LCD_LP, LCD_DCLK, LCD_FP, LCD_ENAB_M, and LCD_LE are low. 1 = LCD enabled. Signals LCD_LP, LCD_DCLK, LCD_FP, LCD_ENAB_M, and LCD_LE are high. See LCD power-up and power-down sequence for details on LCD power sequencing."] pub type LcdenR = crate :: BitReader ; # [doc = "Field `LCDEN` writer - LCD enable control bit. 0 = LCD disabled. Signals LCD_LP, LCD_DCLK, LCD_FP, LCD_ENAB_M, and LCD_LE are low. 1 = LCD enabled. Signals LCD_LP, LCD_DCLK, LCD_FP, LCD_ENAB_M, and LCD_LE are high. See LCD power-up and power-down sequence for details on LCD power sequencing."] pub type LcdenW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `LCDBPP` reader - LCD bits per pixel. Selects the number of bits per LCD pixel: 000 = 1 bpp. 001 = 2 bpp. 010 = 4 bpp. 011 = 8 bpp. 100 = 16 bpp. 101 = 24 bpp (TFT panel only). 110 = 16 bpp, 5:6:5 mode. 111 = 12 bpp, 4:4:4 mode."] pub type LcdbppR = crate :: FieldReader ; # [doc = "Field `LCDBPP` writer - LCD bits per pixel. Selects the number of bits per LCD pixel: 000 = 1 bpp. 001 = 2 bpp. 010 = 4 bpp. 011 = 8 bpp. 100 = 16 bpp. 101 = 24 bpp (TFT panel only). 110 = 16 bpp, 5:6:5 mode. 111 = 12 bpp, 4:4:4 mode."] pub type LcdbppW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; # [doc = "Field `LCDBW` reader - STN LCD monochrome/color selection. 0 = STN LCD is color. 1 = STN LCD is monochrome. This bit has no meaning in TFT mode."] pub type LcdbwR = crate :: BitReader ; # [doc = "Field `LCDBW` writer - STN LCD monochrome/color selection. 0 = STN LCD is color. 1 = STN LCD is monochrome. This bit has no meaning in TFT mode."] pub type LcdbwW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `LCDTFT` reader - LCD panel TFT type selection. 0 = LCD is an STN display. Use gray scaler. 1 = LCD is a TFT display. Do not use gray scaler."] pub type LcdtftR = crate :: BitReader ; # [doc = "Field `LCDTFT` writer - LCD panel TFT type selection. 0 = LCD is an STN display. Use gray scaler. 1 = LCD is a TFT display. Do not use gray scaler."] pub type LcdtftW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `LCDMONO8` reader - Monochrome LCD interface width. Controls whether a monochrome STN LCD uses a 4 or 8-bit parallel interface. It has no meaning in other modes and must be programmed to zero. 0 = monochrome LCD uses a 4-bit interface. 1 = monochrome LCD uses a 8-bit interface."] pub type Lcdmono8R = crate :: BitReader ; # [doc = "Field `LCDMONO8` writer - Monochrome LCD interface width. Controls whether a monochrome STN LCD uses a 4 or 8-bit parallel interface. It has no meaning in other modes and must be programmed to zero. 0 = monochrome LCD uses a 4-bit interface. 1 = monochrome LCD uses a 8-bit interface."] pub type Lcdmono8W < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `LCDDUAL` reader - Single or Dual LCD panel selection. STN LCD interface is: 0 = single-panel. 1 = dual-panel."] pub type LcddualR = crate :: BitReader ; # [doc = "Field `LCDDUAL` writer - Single or Dual LCD panel selection. STN LCD interface is: 0 = single-panel. 1 = dual-panel."] pub type LcddualW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `BGR` reader - Color format selection. 0 = RGB: normal output. 1 = BGR: red and blue swapped."] pub type BgrR = crate :: BitReader ; # [doc = "Field `BGR` writer - Color format selection. 0 = RGB: normal output. 1 = BGR: red and blue swapped."] pub type BgrW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `BEBO` reader - Big-endian Byte Order. Controls byte ordering in memory: 0 = little-endian byte order. 1 = big-endian byte order."] pub type BeboR = crate :: BitReader ; # [doc = "Field `BEBO` writer - Big-endian Byte Order. Controls byte ordering in memory: 0 = little-endian byte order. 1 = big-endian byte order."] pub type BeboW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `BEPO` reader - Big-Endian Pixel Ordering. Controls pixel ordering within a byte: 0 = little-endian ordering within a byte. 1 = big-endian pixel ordering within a byte. The BEPO bit selects between little and big-endian pixel packing for 1, 2, and 4 bpp display modes, it has no effect on 8 or 16 bpp pixel formats. See Pixel serializer for more information on the data format."] pub type BepoR = crate :: BitReader ; # [doc = "Field `BEPO` writer - Big-Endian Pixel Ordering. Controls pixel ordering within a byte: 0 = little-endian ordering within a byte. 1 = big-endian pixel ordering within a byte. The BEPO bit selects between little and big-endian pixel packing for 1, 2, and 4 bpp display modes, it has no effect on 8 or 16 bpp pixel formats. See Pixel serializer for more information on the data format."] pub type BepoW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `LCDPWR` reader - LCD power enable. 0 = power not gated through to LCD panel and LCD_VD\\[23:0\\] signals disabled, (held LOW). 1 = power gated through to LCD panel and LCD_VD\\[23:0\\] signals enabled, (active). See LCD power-up and power-down sequence for details on LCD power sequencing."] pub type LcdpwrR = crate :: BitReader ; # [doc = "Field `LCDPWR` writer - LCD power enable. 0 = power not gated through to LCD panel and LCD_VD\\[23:0\\] signals disabled, (held LOW). 1 = power gated through to LCD panel and LCD_VD\\[23:0\\] signals enabled, (active). See LCD power-up and power-down sequence for details on LCD power sequencing."] pub type LcdpwrW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `LCDVCOMP` reader - LCD Vertical Compare Interrupt. Generate VComp interrupt at: 00 = start of vertical synchronization. 01 = start of back porch. 10 = start of active video. 11 = start of front porch."] pub type LcdvcompR = crate :: FieldReader ; # [doc = "Field `LCDVCOMP` writer - LCD Vertical Compare Interrupt. Generate VComp interrupt at: 00 = start of vertical synchronization. 01 = start of back porch. 10 = start of active video. 11 = start of front porch."] pub type LcdvcompW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; # [doc = "Field `WATERMARK` reader - LCD DMA FIFO watermark level. Controls when DMA requests are generated: 0 = An LCD DMA request is generated when either of the DMA FIFOs have four or more empty locations. 1 = An LCD DMA request is generated when either of the DMA FIFOs have eight or more empty locations."] pub type WatermarkR = crate :: BitReader ; # [doc = "Field `WATERMARK` writer - LCD DMA FIFO watermark level. Controls when DMA requests are generated: 0 = An LCD DMA request is generated when either of the DMA FIFOs have four or more empty locations. 1 = An LCD DMA request is generated when either of the DMA FIFOs have eight or more empty locations."] pub type WatermarkW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0 - LCD enable control bit. 0 = LCD disabled. Signals LCD_LP, LCD_DCLK, LCD_FP, LCD_ENAB_M, and LCD_LE are low. 1 = LCD enabled. Signals LCD_LP, LCD_DCLK, LCD_FP, LCD_ENAB_M, and LCD_LE are high. See LCD power-up and power-down sequence for details on LCD power sequencing."] # [inline (always)] pub fn lcden (& self) -> LcdenR { LcdenR :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:3 - LCD bits per pixel. Selects the number of bits per LCD pixel: 000 = 1 bpp. 001 = 2 bpp. 010 = 4 bpp. 011 = 8 bpp. 100 = 16 bpp. 101 = 24 bpp (TFT panel only). 110 = 16 bpp, 5:6:5 mode. 111 = 12 bpp, 4:4:4 mode."] # [inline (always)] pub fn lcdbpp (& self) -> LcdbppR { LcdbppR :: new (((self . bits >> 1) & 7) as u8) } # [doc = "Bit 4 - STN LCD monochrome/color selection. 0 = STN LCD is color. 1 = STN LCD is monochrome. This bit has no meaning in TFT mode."] # [inline (always)] pub fn lcdbw (& self) -> LcdbwR { LcdbwR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - LCD panel TFT type selection. 0 = LCD is an STN display. Use gray scaler. 1 = LCD is a TFT display. Do not use gray scaler."] # [inline (always)] pub fn lcdtft (& self) -> LcdtftR { LcdtftR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Monochrome LCD interface width. Controls whether a monochrome STN LCD uses a 4 or 8-bit parallel interface. It has no meaning in other modes and must be programmed to zero. 0 = monochrome LCD uses a 4-bit interface. 1 = monochrome LCD uses a 8-bit interface."] # [inline (always)] pub fn lcdmono8 (& self) -> Lcdmono8R { Lcdmono8R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Single or Dual LCD panel selection. STN LCD interface is: 0 = single-panel. 1 = dual-panel."] # [inline (always)] pub fn lcddual (& self) -> LcddualR { LcddualR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Color format selection. 0 = RGB: normal output. 1 = BGR: red and blue swapped."] # [inline (always)] pub fn bgr (& self) -> BgrR { BgrR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Big-endian Byte Order. Controls byte ordering in memory: 0 = little-endian byte order. 1 = big-endian byte order."] # [inline (always)] pub fn bebo (& self) -> BeboR { BeboR :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Big-Endian Pixel Ordering. Controls pixel ordering within a byte: 0 = little-endian ordering within a byte. 1 = big-endian pixel ordering within a byte. The BEPO bit selects between little and big-endian pixel packing for 1, 2, and 4 bpp display modes, it has no effect on 8 or 16 bpp pixel formats. See Pixel serializer for more information on the data format."] # [inline (always)] pub fn bepo (& self) -> BepoR { BepoR :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - LCD power enable. 0 = power not gated through to LCD panel and LCD_VD\\[23:0\\] signals disabled, (held LOW). 1 = power gated through to LCD panel and LCD_VD\\[23:0\\] signals enabled, (active). See LCD power-up and power-down sequence for details on LCD power sequencing."] # [inline (always)] pub fn lcdpwr (& self) -> LcdpwrR { LcdpwrR :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bits 12:13 - LCD Vertical Compare Interrupt. Generate VComp interrupt at: 00 = start of vertical synchronization. 01 = start of back porch. 10 = start of active video. 11 = start of front porch."] # [inline (always)] pub fn lcdvcomp (& self) -> LcdvcompR { LcdvcompR :: new (((self . bits >> 12) & 3) as u8) } # [doc = "Bit 16 - LCD DMA FIFO watermark level. Controls when DMA requests are generated: 0 = An LCD DMA request is generated when either of the DMA FIFOs have four or more empty locations. 1 = An LCD DMA request is generated when either of the DMA FIFOs have eight or more empty locations."] # [inline (always)] pub fn watermark (& self) -> WatermarkR { WatermarkR :: new (((self . bits >> 16) & 1) != 0) } } impl W { # [doc = "Bit 0 - LCD enable control bit. 0 = LCD disabled. Signals LCD_LP, LCD_DCLK, LCD_FP, LCD_ENAB_M, and LCD_LE are low. 1 = LCD enabled. Signals LCD_LP, LCD_DCLK, LCD_FP, LCD_ENAB_M, and LCD_LE are high. See LCD power-up and power-down sequence for details on LCD power sequencing."] # [inline (always)] pub fn lcden (& mut self) -> LcdenW < '_ , CtrlSpec > { LcdenW :: new (self , 0) } # [doc = "Bits 1:3 - LCD bits per pixel. Selects the number of bits per LCD pixel: 000 = 1 bpp. 001 = 2 bpp. 010 = 4 bpp. 011 = 8 bpp. 100 = 16 bpp. 101 = 24 bpp (TFT panel only). 110 = 16 bpp, 5:6:5 mode. 111 = 12 bpp, 4:4:4 mode."] # [inline (always)] pub fn lcdbpp (& mut self) -> LcdbppW < '_ , CtrlSpec > { LcdbppW :: new (self , 1) } # [doc = "Bit 4 - STN LCD monochrome/color selection. 0 = STN LCD is color. 1 = STN LCD is monochrome. This bit has no meaning in TFT mode."] # [inline (always)] pub fn lcdbw (& mut self) -> LcdbwW < '_ , CtrlSpec > { LcdbwW :: new (self , 4) } # [doc = "Bit 5 - LCD panel TFT type selection. 0 = LCD is an STN display. Use gray scaler. 1 = LCD is a TFT display. Do not use gray scaler."] # [inline (always)] pub fn lcdtft (& mut self) -> LcdtftW < '_ , CtrlSpec > { LcdtftW :: new (self , 5) } # [doc = "Bit 6 - Monochrome LCD interface width. Controls whether a monochrome STN LCD uses a 4 or 8-bit parallel interface. It has no meaning in other modes and must be programmed to zero. 0 = monochrome LCD uses a 4-bit interface. 1 = monochrome LCD uses a 8-bit interface."] # [inline (always)] pub fn lcdmono8 (& mut self) -> Lcdmono8W < '_ , CtrlSpec > { Lcdmono8W :: new (self , 6) } # [doc = "Bit 7 - Single or Dual LCD panel selection. STN LCD interface is: 0 = single-panel. 1 = dual-panel."] # [inline (always)] pub fn lcddual (& mut self) -> LcddualW < '_ , CtrlSpec > { LcddualW :: new (self , 7) } # [doc = "Bit 8 - Color format selection. 0 = RGB: normal output. 1 = BGR: red and blue swapped."] # [inline (always)] pub fn bgr (& mut self) -> BgrW < '_ , CtrlSpec > { BgrW :: new (self , 8) } # [doc = "Bit 9 - Big-endian Byte Order. Controls byte ordering in memory: 0 = little-endian byte order. 1 = big-endian byte order."] # [inline (always)] pub fn bebo (& mut self) -> BeboW < '_ , CtrlSpec > { BeboW :: new (self , 9) } # [doc = "Bit 10 - Big-Endian Pixel Ordering. Controls pixel ordering within a byte: 0 = little-endian ordering within a byte. 1 = big-endian pixel ordering within a byte. The BEPO bit selects between little and big-endian pixel packing for 1, 2, and 4 bpp display modes, it has no effect on 8 or 16 bpp pixel formats. See Pixel serializer for more information on the data format."] # [inline (always)] pub fn bepo (& mut self) -> BepoW < '_ , CtrlSpec > { BepoW :: new (self , 10) } # [doc = "Bit 11 - LCD power enable. 0 = power not gated through to LCD panel and LCD_VD\\[23:0\\] signals disabled, (held LOW). 1 = power gated through to LCD panel and LCD_VD\\[23:0\\] signals enabled, (active). See LCD power-up and power-down sequence for details on LCD power sequencing."] # [inline (always)] pub fn lcdpwr (& mut self) -> LcdpwrW < '_ , CtrlSpec > { LcdpwrW :: new (self , 11) } # [doc = "Bits 12:13 - LCD Vertical Compare Interrupt. Generate VComp interrupt at: 00 = start of vertical synchronization. 01 = start of back porch. 10 = start of active video. 11 = start of front porch."] # [inline (always)] pub fn lcdvcomp (& mut self) -> LcdvcompW < '_ , CtrlSpec > { LcdvcompW :: new (self , 12) } # [doc = "Bit 16 - LCD DMA FIFO watermark level. Controls when DMA requests are generated: 0 = An LCD DMA request is generated when either of the DMA FIFOs have four or more empty locations. 1 = An LCD DMA request is generated when either of the DMA FIFOs have eight or more empty locations."] # [inline (always)] pub fn watermark (& mut self) -> WatermarkW < '_ , CtrlSpec > { WatermarkW :: new (self , 16) } } # [doc = "LCD Control register\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct CtrlSpec ; impl crate :: RegisterSpec for CtrlSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ctrl::R`](R) reader structure"] impl crate :: Readable for CtrlSpec { } # [doc = "`write(|w| ..)` method takes [`ctrl::W`](W) writer structure"] impl crate :: Writable for CtrlSpec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets CTRL to value 0"] impl crate :: Resettable for CtrlSpec { }