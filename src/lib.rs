# ! [doc = "Peripheral access API for NEOM3 microcontrollers (generated using svd2rust v0.37.0 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next] svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.37.0/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"] # ! [allow (non_camel_case_types)] # ! [allow (non_snake_case)] # ! [no_std] # ! [cfg_attr (docsrs , feature (doc_auto_cfg))] # [doc = r"Number available in the NVIC for configuring priority"] pub const NVIC_PRIO_BITS : u8 = 3 ; # [allow (unused_imports)] use generic :: * ; # [doc = r"Common register and bit access and modify traits"] pub mod generic ; # [cfg (feature = "rt")] extern "C" { fn WWDT () ; fn TIMER0 () ; fn TIMER1 () ; fn TIMER2 () ; fn TIMER3 () ; fn UART0 () ; fn UART1 () ; fn UART2 () ; fn UART3 () ; fn PWM1 () ; fn I2C0 () ; fn I2C1 () ; fn I2C2 () ; fn SSP0 () ; fn SSP1 () ; fn RTC () ; fn EINT0 () ; fn EINT1 () ; fn EINT2 () ; fn EINT3 () ; fn ADC () ; fn BOD () ; fn USB () ; fn CAN () ; fn GPDMA () ; fn I2S () ; fn ETHERNET () ; fn SDMMC () ; fn MCPWM () ; fn QEI () ; fn USB_NEED_CLK () ; fn UART4 () ; fn SSP2 () ; fn LCD () ; fn GPIOINT () ; fn PWM0 () ; fn EEPROM () ; } # [doc (hidden)] # [repr (C)] pub union Vector { _handler : unsafe extern "C" fn () , _reserved : u32 , } # [cfg (feature = "rt")] # [doc (hidden)] # [link_section = ".vector_table.interrupts"] # [no_mangle] pub static __INTERRUPTS : [Vector ; 41] = [Vector { _handler : WWDT } , Vector { _handler : TIMER0 } , Vector { _handler : TIMER1 } , Vector { _handler : TIMER2 } , Vector { _handler : TIMER3 } , Vector { _handler : UART0 } , Vector { _handler : UART1 } , Vector { _handler : UART2 } , Vector { _handler : UART3 } , Vector { _handler : PWM1 } , Vector { _handler : I2C0 } , Vector { _handler : I2C1 } , Vector { _handler : I2C2 } , Vector { _reserved : 0 } , Vector { _handler : SSP0 } , Vector { _handler : SSP1 } , Vector { _reserved : 0 } , Vector { _handler : RTC } , Vector { _handler : EINT0 } , Vector { _handler : EINT1 } , Vector { _handler : EINT2 } , Vector { _handler : EINT3 } , Vector { _handler : ADC } , Vector { _handler : BOD } , Vector { _handler : USB } , Vector { _handler : CAN } , Vector { _handler : GPDMA } , Vector { _handler : I2S } , Vector { _handler : ETHERNET } , Vector { _handler : SDMMC } , Vector { _handler : MCPWM } , Vector { _handler : QEI } , Vector { _reserved : 0 } , Vector { _handler : USB_NEED_CLK } , Vector { _reserved : 0 } , Vector { _handler : UART4 } , Vector { _handler : SSP2 } , Vector { _handler : LCD } , Vector { _handler : GPIOINT } , Vector { _handler : PWM0 } , Vector { _handler : EEPROM } ,] ; # [doc = r"Enumeration of all the interrupts."] # [derive (Copy , Clone , Debug , PartialEq , Eq)] # [repr (u16)] pub enum Interrupt { # [doc = "0 - WWDT"] WWDT = 0 , # [doc = "1 - TIMER0"] TIMER0 = 1 , # [doc = "2 - TIMER1"] TIMER1 = 2 , # [doc = "3 - TIMER2"] TIMER2 = 3 , # [doc = "4 - TIMER3"] TIMER3 = 4 , # [doc = "5 - UART0"] UART0 = 5 , # [doc = "6 - UART1"] UART1 = 6 , # [doc = "7 - UART2"] UART2 = 7 , # [doc = "8 - UART3"] UART3 = 8 , # [doc = "9 - PWM1"] PWM1 = 9 , # [doc = "10 - I2C0"] I2C0 = 10 , # [doc = "11 - I2C1"] I2C1 = 11 , # [doc = "12 - I2C2"] I2C2 = 12 , # [doc = "14 - SSP0"] SSP0 = 14 , # [doc = "15 - SSP1"] SSP1 = 15 , # [doc = "17 - RTC"] RTC = 17 , # [doc = "18 - EINT0"] EINT0 = 18 , # [doc = "19 - EINT1"] EINT1 = 19 , # [doc = "20 - EINT2"] EINT2 = 20 , # [doc = "21 - EINT3"] EINT3 = 21 , # [doc = "22 - ADC"] ADC = 22 , # [doc = "23 - BOD"] BOD = 23 , # [doc = "24 - USB"] USB = 24 , # [doc = "25 - CAN"] CAN = 25 , # [doc = "26 - GPDMA"] GPDMA = 26 , # [doc = "27 - I2S"] I2S = 27 , # [doc = "28 - ETHERNET"] ETHERNET = 28 , # [doc = "29 - SDMMC"] SDMMC = 29 , # [doc = "30 - MCPWM"] MCPWM = 30 , # [doc = "31 - QEI"] QEI = 31 , # [doc = "33 - USB_NEED_CLK"] USB_NEED_CLK = 33 , # [doc = "35 - UART4"] UART4 = 35 , # [doc = "36 - SSP2"] SSP2 = 36 , # [doc = "37 - LCD"] LCD = 37 , # [doc = "38 - GPIOINT"] GPIOINT = 38 , # [doc = "39 - PWM0"] PWM0 = 39 , # [doc = "40 - EEPROM"] EEPROM = 40 , } unsafe impl cortex_m :: interrupt :: InterruptNumber for Interrupt { # [inline (always)] fn number (self) -> u16 { self as u16 } } # [doc = "Flash control block"] pub type Flashctrl = crate :: Periph < flashctrl :: RegisterBlock , 0x0020_0000 > ; impl core :: fmt :: Debug for Flashctrl { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Flashctrl") . finish () } } # [doc = "Flash control block"] pub mod flashctrl ; # [doc = "General purpose DMA controller"] pub type Gpdma = crate :: Periph < gpdma :: RegisterBlock , 0x2008_0000 > ; impl core :: fmt :: Debug for Gpdma { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gpdma") . finish () } } # [doc = "General purpose DMA controller"] pub mod gpdma ; # [doc = "Ethernet"] pub type Ethernet = crate :: Periph < ethernet :: RegisterBlock , 0x2008_4000 > ; impl core :: fmt :: Debug for Ethernet { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ethernet") . finish () } } # [doc = "Ethernet"] pub mod ethernet ; # [doc = "LCD controller"] pub type Lcd = crate :: Periph < lcd :: RegisterBlock , 0x2008_8000 > ; impl core :: fmt :: Debug for Lcd { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Lcd") . finish () } } # [doc = "LCD controller"] pub mod lcd ; # [doc = "USB device/host/OTG controller"] pub type Usb = crate :: Periph < usb :: RegisterBlock , 0x2008_c000 > ; impl core :: fmt :: Debug for Usb { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Usb") . finish () } } # [doc = "USB device/host/OTG controller"] pub mod usb ; # [doc = "CRC engine"] pub type Crc = crate :: Periph < crc :: RegisterBlock , 0x2009_0000 > ; impl core :: fmt :: Debug for Crc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Crc") . finish () } } # [doc = "CRC engine"] pub mod crc ; # [doc = "General Purpose I/O"] pub type Gpio = crate :: Periph < gpio :: RegisterBlock , 0x2009_8000 > ; impl core :: fmt :: Debug for Gpio { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gpio") . finish () } } # [doc = "General Purpose I/O"] pub mod gpio ; # [doc = "ExternalMemory Controller (EMC)"] pub type Emc = crate :: Periph < emc :: RegisterBlock , 0x2009_c000 > ; impl core :: fmt :: Debug for Emc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Emc") . finish () } } # [doc = "ExternalMemory Controller (EMC)"] pub mod emc ; # [doc = "Windowed Watchdog Timer (WWDT)"] pub type Wwdt = crate :: Periph < wwdt :: RegisterBlock , 0x4000_0000 > ; impl core :: fmt :: Debug for Wwdt { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Wwdt") . finish () } } # [doc = "Windowed Watchdog Timer (WWDT)"] pub mod wwdt ; # [doc = "Timer0/1/2/3"] pub type Timer0 = crate :: Periph < timer0 :: RegisterBlock , 0x4000_4000 > ; impl core :: fmt :: Debug for Timer0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Timer0") . finish () } } # [doc = "Timer0/1/2/3"] pub mod timer0 ; # [doc = "Timer0/1/2/3"] pub type Timer1 = crate :: Periph < timer0 :: RegisterBlock , 0x4000_8000 > ; impl core :: fmt :: Debug for Timer1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Timer1") . finish () } } # [doc = "Timer0/1/2/3"] pub use self :: timer0 as timer1 ; # [doc = "UART0/2/3"] pub type Uart0 = crate :: Periph < uart0 :: RegisterBlock , 0x4000_c000 > ; impl core :: fmt :: Debug for Uart0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Uart0") . finish () } } # [doc = "UART0/2/3"] pub mod uart0 ; # [doc = "UART1"] pub type Uart1 = crate :: Periph < uart1 :: RegisterBlock , 0x4001_0000 > ; impl core :: fmt :: Debug for Uart1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Uart1") . finish () } } # [doc = "UART1"] pub mod uart1 ; # [doc = "Pulse Width Modulators (PWM0/1)"] pub type Pwm0 = crate :: Periph < pwm0 :: RegisterBlock , 0x4001_4000 > ; impl core :: fmt :: Debug for Pwm0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Pwm0") . finish () } } # [doc = "Pulse Width Modulators (PWM0/1)"] pub mod pwm0 ; # [doc = "Pulse Width Modulators (PWM0/1)"] pub type Pwm1 = crate :: Periph < pwm0 :: RegisterBlock , 0x4001_8000 > ; impl core :: fmt :: Debug for Pwm1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Pwm1") . finish () } } # [doc = "Pulse Width Modulators (PWM0/1)"] pub use self :: pwm0 as pwm1 ; # [doc = "I2C bus interface"] pub type I2c0 = crate :: Periph < i2c0 :: RegisterBlock , 0x4001_c000 > ; impl core :: fmt :: Debug for I2c0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("I2c0") . finish () } } # [doc = "I2C bus interface"] pub mod i2c0 ; # [doc = "Real Time Clock (RTC)"] pub type Rtc = crate :: Periph < rtc :: RegisterBlock , 0x4002_4000 > ; impl core :: fmt :: Debug for Rtc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Rtc") . finish () } } # [doc = "Real Time Clock (RTC)"] pub mod rtc ; # [doc = "GPIO"] pub type Gpioint = crate :: Periph < gpioint :: RegisterBlock , 0x4002_8080 > ; impl core :: fmt :: Debug for Gpioint { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gpioint") . finish () } } # [doc = "GPIO"] pub mod gpioint ; # [doc = "IOCON pin configuration"] pub type Iocon = crate :: Periph < iocon :: RegisterBlock , 0x4002_c000 > ; impl core :: fmt :: Debug for Iocon { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Iocon") . finish () } } # [doc = "IOCON pin configuration"] pub mod iocon ; # [doc = "SSP1 controller"] pub type Ssp1 = crate :: Periph < ssp1 :: RegisterBlock , 0x4003_0000 > ; impl core :: fmt :: Debug for Ssp1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ssp1") . finish () } } # [doc = "SSP1 controller"] pub mod ssp1 ; # [doc = "Analog-to-Digital Converter (ADC)"] pub type Adc = crate :: Periph < adc :: RegisterBlock , 0x4003_4000 > ; impl core :: fmt :: Debug for Adc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Adc") . finish () } } # [doc = "Analog-to-Digital Converter (ADC)"] pub mod adc ; # [doc = "CAN acceptance filter RAM"] pub type Canafram = crate :: Periph < canafram :: RegisterBlock , 0x4003_8000 > ; impl core :: fmt :: Debug for Canafram { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Canafram") . finish () } } # [doc = "CAN acceptance filter RAM"] pub mod canafram ; # [doc = "CAN controller acceptance filter"] pub type Canaf = crate :: Periph < canaf :: RegisterBlock , 0x4003_c000 > ; impl core :: fmt :: Debug for Canaf { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Canaf") . finish () } } # [doc = "CAN controller acceptance filter"] pub mod canaf ; # [doc = "Central CAN controller"] pub type Ccan = crate :: Periph < ccan :: RegisterBlock , 0x4004_0000 > ; impl core :: fmt :: Debug for Ccan { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ccan") . finish () } } # [doc = "Central CAN controller"] pub mod ccan ; # [doc = "CAN1 controller"] pub type Can1 = crate :: Periph < can1 :: RegisterBlock , 0x4004_4000 > ; impl core :: fmt :: Debug for Can1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Can1") . finish () } } # [doc = "CAN1 controller"] pub mod can1 ; # [doc = "CAN1 controller"] pub type Can2 = crate :: Periph < can1 :: RegisterBlock , 0x4004_8000 > ; impl core :: fmt :: Debug for Can2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Can2") . finish () } } # [doc = "CAN1 controller"] pub use self :: can1 as can2 ; # [doc = "I2C bus interface"] pub type I2c1 = crate :: Periph < i2c0 :: RegisterBlock , 0x4005_c000 > ; impl core :: fmt :: Debug for I2c1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("I2c1") . finish () } } # [doc = "I2C bus interface"] pub use self :: i2c0 as i2c1 ; # [doc = "SSP controller"] pub type Ssp0 = crate :: Periph < ssp1 :: RegisterBlock , 0x4008_8000 > ; impl core :: fmt :: Debug for Ssp0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ssp0") . finish () } } # [doc = "SSP controller"] pub use self :: ssp1 as ssp0 ; # [doc = "Digital-to-Analog Converter (DAC)"] pub type Dac = crate :: Periph < dac :: RegisterBlock , 0x4008_c000 > ; impl core :: fmt :: Debug for Dac { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dac") . finish () } } # [doc = "Digital-to-Analog Converter (DAC)"] pub mod dac ; # [doc = "Timer0/1/2/3"] pub type Timer2 = crate :: Periph < timer0 :: RegisterBlock , 0x4009_0000 > ; impl core :: fmt :: Debug for Timer2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Timer2") . finish () } } # [doc = "Timer0/1/2/3"] pub use self :: timer0 as timer2 ; # [doc = "Timer0/1/2/3"] pub type Timer3 = crate :: Periph < timer0 :: RegisterBlock , 0x4009_4000 > ; impl core :: fmt :: Debug for Timer3 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Timer3") . finish () } } # [doc = "Timer0/1/2/3"] pub use self :: timer0 as timer3 ; # [doc = "UART0/2/3"] pub type Uart2 = crate :: Periph < uart0 :: RegisterBlock , 0x4009_8000 > ; impl core :: fmt :: Debug for Uart2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Uart2") . finish () } } # [doc = "UART0/2/3"] pub use self :: uart0 as uart2 ; # [doc = "UART0/2/3"] pub type Uart3 = crate :: Periph < uart0 :: RegisterBlock , 0x4009_c000 > ; impl core :: fmt :: Debug for Uart3 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Uart3") . finish () } } # [doc = "UART0/2/3"] pub use self :: uart0 as uart3 ; # [doc = "I2C bus interface"] pub type I2c2 = crate :: Periph < i2c0 :: RegisterBlock , 0x400a_0000 > ; impl core :: fmt :: Debug for I2c2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("I2c2") . finish () } } # [doc = "I2C bus interface"] pub use self :: i2c0 as i2c2 ; # [doc = "UART4"] pub type Uart4 = crate :: Periph < uart4 :: RegisterBlock , 0x400a_4000 > ; impl core :: fmt :: Debug for Uart4 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Uart4") . finish () } } # [doc = "UART4"] pub mod uart4 ; # [doc = "I2S interface"] pub type I2s = crate :: Periph < i2s :: RegisterBlock , 0x400a_8000 > ; impl core :: fmt :: Debug for I2s { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("I2s") . finish () } } # [doc = "I2S interface"] pub mod i2s ; # [doc = "SSP controller"] pub type Ssp2 = crate :: Periph < ssp1 :: RegisterBlock , 0x400a_c000 > ; impl core :: fmt :: Debug for Ssp2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Ssp2") . finish () } } # [doc = "SSP controller"] pub use self :: ssp1 as ssp2 ; # [doc = "Motor Control PWM"] pub type Mcpwm = crate :: Periph < mcpwm :: RegisterBlock , 0x400b_8000 > ; impl core :: fmt :: Debug for Mcpwm { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Mcpwm") . finish () } } # [doc = "Motor Control PWM"] pub mod mcpwm ; # [doc = "Quadrature Encoder Interface (QEI)"] pub type Qei = crate :: Periph < qei :: RegisterBlock , 0x400b_c000 > ; impl core :: fmt :: Debug for Qei { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Qei") . finish () } } # [doc = "Quadrature Encoder Interface (QEI)"] pub mod qei ; # [doc = "SD card interface"] pub type Sdmmc = crate :: Periph < sdmmc :: RegisterBlock , 0x400c_0000 > ; impl core :: fmt :: Debug for Sdmmc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Sdmmc") . finish () } } # [doc = "SD card interface"] pub mod sdmmc ; # [doc = "System and clock control"] pub type Syscon = crate :: Periph < syscon :: RegisterBlock , 0x400f_c000 > ; impl core :: fmt :: Debug for Syscon { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Syscon") . finish () } } # [doc = "System and clock control"] pub mod syscon ; # [no_mangle] static mut DEVICE_PERIPHERALS : bool = false ; # [doc = r" All the peripherals."] # [allow (non_snake_case)] pub struct Peripherals { # [doc = "FLASHCTRL"] pub flashctrl : Flashctrl , # [doc = "GPDMA"] pub gpdma : Gpdma , # [doc = "ETHERNET"] pub ethernet : Ethernet , # [doc = "LCD"] pub lcd : Lcd , # [doc = "USB"] pub usb : Usb , # [doc = "CRC"] pub crc : Crc , # [doc = "GPIO"] pub gpio : Gpio , # [doc = "EMC"] pub emc : Emc , # [doc = "WWDT"] pub wwdt : Wwdt , # [doc = "TIMER0"] pub timer0 : Timer0 , # [doc = "TIMER1"] pub timer1 : Timer1 , # [doc = "UART0"] pub uart0 : Uart0 , # [doc = "UART1"] pub uart1 : Uart1 , # [doc = "PWM0"] pub pwm0 : Pwm0 , # [doc = "PWM1"] pub pwm1 : Pwm1 , # [doc = "I2C0"] pub i2c0 : I2c0 , # [doc = "RTC"] pub rtc : Rtc , # [doc = "GPIOINT"] pub gpioint : Gpioint , # [doc = "IOCON"] pub iocon : Iocon , # [doc = "SSP1"] pub ssp1 : Ssp1 , # [doc = "ADC"] pub adc : Adc , # [doc = "CANAFRAM"] pub canafram : Canafram , # [doc = "CANAF"] pub canaf : Canaf , # [doc = "CCAN"] pub ccan : Ccan , # [doc = "CAN1"] pub can1 : Can1 , # [doc = "CAN2"] pub can2 : Can2 , # [doc = "I2C1"] pub i2c1 : I2c1 , # [doc = "SSP0"] pub ssp0 : Ssp0 , # [doc = "DAC"] pub dac : Dac , # [doc = "TIMER2"] pub timer2 : Timer2 , # [doc = "TIMER3"] pub timer3 : Timer3 , # [doc = "UART2"] pub uart2 : Uart2 , # [doc = "UART3"] pub uart3 : Uart3 , # [doc = "I2C2"] pub i2c2 : I2c2 , # [doc = "UART4"] pub uart4 : Uart4 , # [doc = "I2S"] pub i2s : I2s , # [doc = "SSP2"] pub ssp2 : Ssp2 , # [doc = "MCPWM"] pub mcpwm : Mcpwm , # [doc = "QEI"] pub qei : Qei , # [doc = "SDMMC"] pub sdmmc : Sdmmc , # [doc = "SYSCON"] pub syscon : Syscon , } impl Peripherals { # [doc = r" Returns all the peripherals *once*."] # [cfg (feature = "critical-section")] # [inline] pub fn take () -> Option < Self > { critical_section :: with (| _ | { if unsafe { DEVICE_PERIPHERALS } { return None } Some (unsafe { Peripherals :: steal () }) }) } # [doc = r" Unchecked version of `Peripherals::take`."] # [doc = r""] # [doc = r" # Safety"] # [doc = r""] # [doc = r" Each of the returned peripherals must be used at most once."] # [inline] pub unsafe fn steal () -> Self { DEVICE_PERIPHERALS = true ; Peripherals { flashctrl : Flashctrl :: steal () , gpdma : Gpdma :: steal () , ethernet : Ethernet :: steal () , lcd : Lcd :: steal () , usb : Usb :: steal () , crc : Crc :: steal () , gpio : Gpio :: steal () , emc : Emc :: steal () , wwdt : Wwdt :: steal () , timer0 : Timer0 :: steal () , timer1 : Timer1 :: steal () , uart0 : Uart0 :: steal () , uart1 : Uart1 :: steal () , pwm0 : Pwm0 :: steal () , pwm1 : Pwm1 :: steal () , i2c0 : I2c0 :: steal () , rtc : Rtc :: steal () , gpioint : Gpioint :: steal () , iocon : Iocon :: steal () , ssp1 : Ssp1 :: steal () , adc : Adc :: steal () , canafram : Canafram :: steal () , canaf : Canaf :: steal () , ccan : Ccan :: steal () , can1 : Can1 :: steal () , can2 : Can2 :: steal () , i2c1 : I2c1 :: steal () , ssp0 : Ssp0 :: steal () , dac : Dac :: steal () , timer2 : Timer2 :: steal () , timer3 : Timer3 :: steal () , uart2 : Uart2 :: steal () , uart3 : Uart3 :: steal () , i2c2 : I2c2 :: steal () , uart4 : Uart4 :: steal () , i2s : I2s :: steal () , ssp2 : Ssp2 :: steal () , mcpwm : Mcpwm :: steal () , qei : Qei :: steal () , sdmmc : Sdmmc :: steal () , syscon : Syscon :: steal () , } } }