# [doc = "Register `ACR` reader"] pub type R = crate :: R < AcrSpec > ; # [doc = "Register `ACR` writer"] pub type W = crate :: W < AcrSpec > ; # [doc = "Auto-baud start bit. This bit is automatically cleared after auto-baud completion.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Enum { # [doc = "0: Auto-baud stop (auto-baud is not running)."] Stop = 0 , # [doc = "1: Auto-baud start (auto-baud is running). Auto-baud run bit. This bit is automatically cleared after auto-baud completion."] Start = 1 , } impl From < Enum > for bool { # [inline (always)] fn from (variant : Enum) -> Self { variant as u8 != 0 } } # [doc = "Field `START` reader - Auto-baud start bit. This bit is automatically cleared after auto-baud completion."] pub type StartR = crate :: BitReader < Enum > ; impl StartR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Enum { match self . bits { false => Enum :: Stop , true => Enum :: Start , } } # [doc = "Auto-baud stop (auto-baud is not running)."] # [inline (always)] pub fn is_stop (& self) -> bool { * self == Enum :: Stop } # [doc = "Auto-baud start (auto-baud is running). Auto-baud run bit. This bit is automatically cleared after auto-baud completion."] # [inline (always)] pub fn is_start (& self) -> bool { * self == Enum :: Start } } # [doc = "Field `START` writer - Auto-baud start bit. This bit is automatically cleared after auto-baud completion."] pub type StartW < 'a , REG > = crate :: BitWriter < 'a , REG , Enum > ; impl < 'a , REG > StartW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Auto-baud stop (auto-baud is not running)."] # [inline (always)] pub fn stop (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: Stop) } # [doc = "Auto-baud start (auto-baud is running). Auto-baud run bit. This bit is automatically cleared after auto-baud completion."] # [inline (always)] pub fn start (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: Start) } } # [doc = "Auto-baud mode select bit.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Enum { # [doc = "0: Mode 0."] Mode0_ = 0 , # [doc = "1: Mode 1."] Mode1_ = 1 , } impl From < Enum > for bool { # [inline (always)] fn from (variant : Enum) -> Self { variant as u8 != 0 } } # [doc = "Field `MODE` reader - Auto-baud mode select bit."] pub type ModeR = crate :: BitReader < Enum > ; impl ModeR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Enum { match self . bits { false => Enum :: Mode0_ , true => Enum :: Mode1_ , } } # [doc = "Mode 0."] # [inline (always)] pub fn is_mode_0_ (& self) -> bool { * self == Enum :: Mode0_ } # [doc = "Mode 1."] # [inline (always)] pub fn is_mode_1_ (& self) -> bool { * self == Enum :: Mode1_ } } # [doc = "Field `MODE` writer - Auto-baud mode select bit."] pub type ModeW < 'a , REG > = crate :: BitWriter < 'a , REG , Enum > ; impl < 'a , REG > ModeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Mode 0."] # [inline (always)] pub fn mode_0_ (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: Mode0_) } # [doc = "Mode 1."] # [inline (always)] pub fn mode_1_ (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: Mode1_) } } # [doc = "Auto-baud restart bit.\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Enum { # [doc = "0: No restart"] NoRestart = 0 , # [doc = "1: Restart in case of time-out (counter restarts at next UART1 Rx falling edge)"] RestartInCaseOfT = 1 , } impl From < Enum > for bool { # [inline (always)] fn from (variant : Enum) -> Self { variant as u8 != 0 } } # [doc = "Field `AUTORESTART` reader - Auto-baud restart bit."] pub type AutorestartR = crate :: BitReader < Enum > ; impl AutorestartR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Enum { match self . bits { false => Enum :: NoRestart , true => Enum :: RestartInCaseOfT , } } # [doc = "No restart"] # [inline (always)] pub fn is_no_restart (& self) -> bool { * self == Enum :: NoRestart } # [doc = "Restart in case of time-out (counter restarts at next UART1 Rx falling edge)"] # [inline (always)] pub fn is_restart_in_case_of_t (& self) -> bool { * self == Enum :: RestartInCaseOfT } } # [doc = "Field `AUTORESTART` writer - Auto-baud restart bit."] pub type AutorestartW < 'a , REG > = crate :: BitWriter < 'a , REG , Enum > ; impl < 'a , REG > AutorestartW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "No restart"] # [inline (always)] pub fn no_restart (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: NoRestart) } # [doc = "Restart in case of time-out (counter restarts at next UART1 Rx falling edge)"] # [inline (always)] pub fn restart_in_case_of_t (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: RestartInCaseOfT) } } # [doc = "End of auto-baud interrupt clear bit (write-only).\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Enum { # [doc = "0: Writing a 0 has no impact."] WritingA0HasNoI = 0 , # [doc = "1: Writing a 1 will clear the corresponding interrupt in the IIR."] WritingA1WillCle = 1 , } impl From < Enum > for bool { # [inline (always)] fn from (variant : Enum) -> Self { variant as u8 != 0 } } # [doc = "Field `ABEOINTCLR` reader - End of auto-baud interrupt clear bit (write-only)."] pub type AbeointclrR = crate :: BitReader < Enum > ; impl AbeointclrR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Enum { match self . bits { false => Enum :: WritingA0HasNoI , true => Enum :: WritingA1WillCle , } } # [doc = "Writing a 0 has no impact."] # [inline (always)] pub fn is_writing_a_0_has_no_i (& self) -> bool { * self == Enum :: WritingA0HasNoI } # [doc = "Writing a 1 will clear the corresponding interrupt in the IIR."] # [inline (always)] pub fn is_writing_a_1_will_cle (& self) -> bool { * self == Enum :: WritingA1WillCle } } # [doc = "Field `ABEOINTCLR` writer - End of auto-baud interrupt clear bit (write-only)."] pub type AbeointclrW < 'a , REG > = crate :: BitWriter < 'a , REG , Enum > ; impl < 'a , REG > AbeointclrW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Writing a 0 has no impact."] # [inline (always)] pub fn writing_a_0_has_no_i (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: WritingA0HasNoI) } # [doc = "Writing a 1 will clear the corresponding interrupt in the IIR."] # [inline (always)] pub fn writing_a_1_will_cle (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: WritingA1WillCle) } } # [doc = "Auto-baud time-out interrupt clear bit (write-only).\n\nValue on reset: 0"] # [derive (Clone , Copy , Debug , PartialEq , Eq)] pub enum Enum { # [doc = "0: Writing a 0 has no impact."] WritingA0HasNoI = 0 , # [doc = "1: Writing a 1 will clear the corresponding interrupt in the IIR."] WritingA1WillCle = 1 , } impl From < Enum > for bool { # [inline (always)] fn from (variant : Enum) -> Self { variant as u8 != 0 } } # [doc = "Field `ABTOINTCLR` reader - Auto-baud time-out interrupt clear bit (write-only)."] pub type AbtointclrR = crate :: BitReader < Enum > ; impl AbtointclrR { # [doc = "Get enumerated values variant"] # [inline (always)] pub const fn variant (& self) -> Enum { match self . bits { false => Enum :: WritingA0HasNoI , true => Enum :: WritingA1WillCle , } } # [doc = "Writing a 0 has no impact."] # [inline (always)] pub fn is_writing_a_0_has_no_i (& self) -> bool { * self == Enum :: WritingA0HasNoI } # [doc = "Writing a 1 will clear the corresponding interrupt in the IIR."] # [inline (always)] pub fn is_writing_a_1_will_cle (& self) -> bool { * self == Enum :: WritingA1WillCle } } # [doc = "Field `ABTOINTCLR` writer - Auto-baud time-out interrupt clear bit (write-only)."] pub type AbtointclrW < 'a , REG > = crate :: BitWriter < 'a , REG , Enum > ; impl < 'a , REG > AbtointclrW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Writing a 0 has no impact."] # [inline (always)] pub fn writing_a_0_has_no_i (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: WritingA0HasNoI) } # [doc = "Writing a 1 will clear the corresponding interrupt in the IIR."] # [inline (always)] pub fn writing_a_1_will_cle (self) -> & 'a mut crate :: W < REG > { self . variant (Enum :: WritingA1WillCle) } } impl R { # [doc = "Bit 0 - Auto-baud start bit. This bit is automatically cleared after auto-baud completion."] # [inline (always)] pub fn start (& self) -> StartR { StartR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Auto-baud mode select bit."] # [inline (always)] pub fn mode (& self) -> ModeR { ModeR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Auto-baud restart bit."] # [inline (always)] pub fn autorestart (& self) -> AutorestartR { AutorestartR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 8 - End of auto-baud interrupt clear bit (write-only)."] # [inline (always)] pub fn abeointclr (& self) -> AbeointclrR { AbeointclrR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Auto-baud time-out interrupt clear bit (write-only)."] # [inline (always)] pub fn abtointclr (& self) -> AbtointclrR { AbtointclrR :: new (((self . bits >> 9) & 1) != 0) } } impl W { # [doc = "Bit 0 - Auto-baud start bit. This bit is automatically cleared after auto-baud completion."] # [inline (always)] pub fn start (& mut self) -> StartW < '_ , AcrSpec > { StartW :: new (self , 0) } # [doc = "Bit 1 - Auto-baud mode select bit."] # [inline (always)] pub fn mode (& mut self) -> ModeW < '_ , AcrSpec > { ModeW :: new (self , 1) } # [doc = "Bit 2 - Auto-baud restart bit."] # [inline (always)] pub fn autorestart (& mut self) -> AutorestartW < '_ , AcrSpec > { AutorestartW :: new (self , 2) } # [doc = "Bit 8 - End of auto-baud interrupt clear bit (write-only)."] # [inline (always)] pub fn abeointclr (& mut self) -> AbeointclrW < '_ , AcrSpec > { AbeointclrW :: new (self , 8) } # [doc = "Bit 9 - Auto-baud time-out interrupt clear bit (write-only)."] # [inline (always)] pub fn abtointclr (& mut self) -> AbtointclrW < '_ , AcrSpec > { AbtointclrW :: new (self , 9) } } # [doc = "Auto-baud Control Register. Contains controls for the auto-baud feature.\n\nYou can [`read`](crate::Reg::read) this register and get [`acr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`acr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."] pub struct AcrSpec ; impl crate :: RegisterSpec for AcrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`acr::R`](R) reader structure"] impl crate :: Readable for AcrSpec { } # [doc = "`write(|w| ..)` method takes [`acr::W`](W) writer structure"] impl crate :: Writable for AcrSpec { type Safety = crate :: Unsafe ; } # [doc = "`reset()` method sets ACR to value 0"] impl crate :: Resettable for AcrSpec { }